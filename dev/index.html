<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · HypertextLiteral.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">HypertextLiteral.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Content-Interpolation"><span>Content Interpolation</span></a></li><li><a class="tocitem" href="#Attribute-Interpolation"><span>Attribute Interpolation</span></a></li><li><a class="tocitem" href="#Cascading-Style-Sheets"><span>Cascading Style Sheets</span></a></li><li><a class="tocitem" href="#Custom-Extensions"><span>Custom Extensions</span></a></li><li><a class="tocitem" href="#Quirks-and-Regression"><span>Quirks &amp; Regression</span></a></li><li><a class="tocitem" href="#Contributing"><span>Contributing</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/clarkevans/HypertextLiteral.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="HypertextLiteral.jl"><a class="docs-heading-anchor" href="#HypertextLiteral.jl">HypertextLiteral.jl</a><a id="HypertextLiteral.jl-1"></a><a class="docs-heading-anchor-permalink" href="#HypertextLiteral.jl" title="Permalink"></a></h1><p>This package provides a Julia string literal, <code>htl</code>, and equivalent macro, <code>@htl</code>, that construct an object that could be rendered to <code>MIME&quot;text/html&quot;</code> displays. These macros support context-sensitive interpolation sensible to the needs of HTML generation.</p><pre><code class="language-julia">using HypertextLiteral</code></pre><p>When printed directly to the console (via <code>show</code>), the output of these macros reproduce a verified expression that generated them.</p><pre><code class="language-julia">name = &quot;World&quot;

htl&quot;&lt;span&gt;Hello $name&lt;/span&gt;&quot;
#-&gt; htl&quot;&lt;span&gt;Hello $name&lt;/span&gt;&quot;

@htl(&quot;&lt;span&gt;Hello $name&lt;/span&gt;&quot;)
#-&gt; @htl &quot;&lt;span&gt;Hello $(name)&lt;/span&gt;&quot;</code></pre><p>When displayed to <code>&quot;text/html&quot;</code> the evaluation is shown.</p><pre><code class="language-julia">name = &quot;World&quot;

display(&quot;text/html&quot;, htl&quot;&lt;span&gt;Hello $name&lt;/span&gt;&quot;)
#-&gt; &lt;span&gt;Hello World&lt;/span&gt;

display(&quot;text/html&quot;, @htl(&quot;&lt;span&gt;Hello $name&lt;/span&gt;&quot;))
#-&gt; &lt;span&gt;Hello World&lt;/span&gt;</code></pre><p>We use <code>NarrativeTest.jl</code> to ensure our examples are correct. After each command is a comment with the expected output. To enhance readability, we&#39;ll also use the following macro.</p><pre><code class="language-julia">macro print(expr)
    :(display(&quot;text/html&quot;, $expr))
end

@print htl&quot;&lt;span&gt;Hello World&lt;/span&gt;&quot;
#-&gt; &lt;span&gt;Hello World&lt;/span&gt;

@print @htl(&quot;&lt;span&gt;Hello World&lt;/span&gt;&quot;)
#-&gt; &lt;span&gt;Hello World&lt;/span&gt;</code></pre><p>Thoughout this tutorial, we&#39;ll mostly stick with the string literal form of this macro, however, the <code>@htl</code> macro form should work equivalently, except for a few cases we annotate.</p><h2 id="Content-Interpolation"><a class="docs-heading-anchor" href="#Content-Interpolation">Content Interpolation</a><a id="Content-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Content-Interpolation" title="Permalink"></a></h2><p>Hypertext literal provides interpolation via <code>$</code>. Within element content, both the ampersand (<code>&amp;</code>) and less-than (<code>&lt;</code>) are escaped.</p><pre><code class="language-julia">book = &quot;Strunk &amp; White&quot;

@print @htl(&quot;&lt;span&gt;Today&#39;s Reading: $book&lt;/span&gt;&quot;)
#-&gt; &lt;span&gt;Today&#39;s Reading: Strunk &amp;amp; White&lt;/span&gt;</code></pre><p>To include a literal <code>$</code> in the output, use <code>\$</code> as one would in a regular Julia string. Other escape sequences, such as <code>\&quot;</code> also work.</p><pre><code class="language-julia">@print htl&quot;They said, \&quot;your total is \$42.50\&quot;.&quot;
#-&gt; They said, &quot;your total is $42.50&quot;.</code></pre><p>String literals can also be triple-quoted, allowing them to span multiple lines. Within triple quotes, single quoted strings can go unescaped, however, we still need to escape the dollar sign (<code>$</code>).</p><pre><code class="language-julia">@print htl&quot;&quot;&quot;They said, &quot;your total is \$42.50&quot;.&quot;&quot;&quot;
#-&gt; They said, &quot;your total is $42.50&quot;.</code></pre><p>Within any of these forms, Julia results can be interpolated using the <code>$(expr)</code> notation. Numeric values (including <code>Bool</code>) and symbols are automatically converted to their string representation.</p><pre><code class="language-julia">@print htl&quot;2+2 = $(2+2)&quot;
#-&gt; 2+2 = 4

@print htl&quot;&lt;bool&gt;$(false)&lt;/bool&gt;&lt;sym&gt;$(:sym)&lt;/sym&gt;&quot;
#-&gt; &lt;bool&gt;false&lt;/bool&gt;&lt;sym&gt;sym&lt;/sym&gt;</code></pre><p>Functions returning string values will be escaped.</p><pre><code class="language-julia">input() = &quot;&lt;script&gt;alert(&#39;a&amp;b!&#39;)&quot;

@print htl&quot;$(input())&quot;
#-&gt; &amp;lt;script&gt;alert(&#39;a&amp;amp;b!&#39;)</code></pre><p>Functions returning <code>HTL</code> objects are not further escaped. This permits us to build reusable HTML templates.</p><pre><code class="language-julia">sq(x) = htl&quot;&lt;span&gt;$(x*x)&lt;/span&gt;&quot;

@print htl&quot;&lt;div&gt;3^2 is $(sq(3))&lt;/div&gt;&quot;
#-&gt; &lt;div&gt;3^2 is &lt;span&gt;9&lt;/span&gt;&lt;/div&gt;</code></pre><p>Within a triple double-quoted <code>htl</code> string, a single double-quoted <code>htl</code> string can be included. This technique works for one level of nesting.</p><pre><code class="language-julia">books = [&quot;Who Gets What &amp; Why&quot;, &quot;Switch&quot;, &quot;Governing The Commons&quot;]

@print htl&quot;&quot;&quot;&lt;ul&gt;$([htl&quot;&lt;li&gt;$b&quot; for b in books])&lt;/ul&gt;&quot;&quot;&quot;
#=&gt;
&lt;ul&gt;&lt;li&gt;Who Gets What &amp;amp; Why&lt;li&gt;Switch&lt;li&gt;Governing The Commons&lt;/ul&gt;
=#</code></pre><p>The equivalent macro syntax supports arbitrary levels of nesting, although we only show one level of nesting here.</p><pre><code class="language-julia">books = [&quot;Who Gets What &amp; Why&quot;, &quot;Switch&quot;, &quot;Governing The Commons&quot;]

@print @htl(&quot;&lt;ul&gt;$(map(books) do b @htl(&quot;&lt;li&gt;$b&quot;) end)&lt;/ul&gt;&quot;)
#=&gt;
&lt;ul&gt;&lt;li&gt;Who Gets What &amp;amp; Why&lt;li&gt;Switch&lt;li&gt;Governing The Commons&lt;/ul&gt;
=#</code></pre><h2 id="Attribute-Interpolation"><a class="docs-heading-anchor" href="#Attribute-Interpolation">Attribute Interpolation</a><a id="Attribute-Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Attribute-Interpolation" title="Permalink"></a></h2><p>Escaping of Julia values depends upon the context: within a double quoted attribute value, the double quote is escaped; single quoted attributes are likewise escaped.</p><pre><code class="language-julia">qval = &quot;\&quot;h&amp;b&#39;&quot;

@print htl&quot;&quot;&quot;&lt;tag double=&quot;$qval&quot; single=&#39;$qval&#39; /&gt;&quot;&quot;&quot;
#-&gt; &lt;tag double=&quot;&amp;quot;h&amp;amp;b&#39;&quot; single=&#39;&quot;h&amp;amp;b&amp;apos;&#39; /&gt;</code></pre><p>Unquoted attributes are also supported. These are serialized using the single quoted style.</p><pre><code class="language-julia">arg = &quot;book=&#39;Strunk &amp; White&#39;&quot;

@print htl&quot;&lt;tag bare=$arg /&gt;&quot;
#-&gt; &lt;tag bare=&#39;book=&amp;apos;Strunk &amp;amp; White&amp;apos;&#39; /&gt;</code></pre><p>Attributes may also be provided by <code>Dict</code> or <code>Pair</code>. Attribute names are normalized, with <code>camelCase</code> and <code>snake_case</code> becoming <code>kebab-case</code>.</p><pre><code class="language-julia"> attributes = Dict(:dataValue =&gt; 42, :data_style =&gt; :green )

 @print @htl(&quot;&lt;div $attributes/&gt;&quot;)
 #-&gt; &lt;div data-value=&#39;42&#39; data-style=&#39;green&#39;/&gt;

 @print @htl(&quot;&lt;div $(:data_value=&gt;42) $(&quot;dataStyle&quot;=&gt;:green)/&gt;&quot;)
 #-&gt; &lt;div data-value=&#39;42&#39; data-style=&#39;green&#39;/&gt;</code></pre><p>Within string literals (but not <code>@htl</code> macro), a compact syntax inspired by named tuples is also supported.</p><pre><code class="language-julia"> @print htl&quot;&lt;div $(data_value=42, dataStyle=:green)/&gt;&quot;
 #-&gt; &lt;div data-value=&#39;42&#39; data-style=&#39;green&#39;/&gt;</code></pre><p>As you can see from this example, symbols and numbers (but not boolean values) are automatically converted within attributes. This works for quoted values as well.</p><pre><code class="language-julia">@print htl&quot;&quot;&quot;&lt;tag numeric=&quot;$(0)&quot; symbol=&#39;$(:sym)&#39;/&gt;&quot;&quot;&quot;
#-&gt; &lt;tag numeric=&quot;0&quot; symbol=&#39;sym&#39;/&gt;</code></pre><p>Within bare attributes, boolean values provide special support for boolean HTML properties, such as <code>&quot;disabled&quot;</code>. When a bare value <code>false</code> then the attribute is removed. When the value is <code>true</code> then the attribute is kept, with value being an empty string (<code>&#39;&#39;</code>).</p><pre><code class="language-julia">@print htl&quot;&lt;button checked=$(true) disabled=$(false)&gt;&quot;
#-&gt; &lt;button checked=&#39;&#39;&gt;</code></pre><h2 id="Cascading-Style-Sheets"><a class="docs-heading-anchor" href="#Cascading-Style-Sheets">Cascading Style Sheets</a><a id="Cascading-Style-Sheets-1"></a><a class="docs-heading-anchor-permalink" href="#Cascading-Style-Sheets" title="Permalink"></a></h2><p>There is special support for the <em>unquoted</em> <code>&quot;style&quot;</code> attribute. In this case, <code>Pair</code> and <code>Dict</code> values are expanded as style attributes separated by the semi-colon (<code>;</code>). Style names that are <code>Symbol</code> values go though <code>camelCase</code> conversion to <code>camel-case</code>, while <code>String</code> values are passed along as-is.</p><pre><code class="language-julia">header_styles = Dict(:fontSize =&gt; &quot;25px&quot;, &quot;padding-left&quot; =&gt; &quot;2em&quot;)

@print htl&quot;&lt;div style=$header_styles/&gt;&quot;
#-&gt; &lt;div style=&#39;font-size: 25px;padding-left: 2em;&#39;/&gt;

@print htl&quot;&quot;&quot;&lt;div style=$(:fontSize=&gt;&quot;25px&quot;,&quot;padding-left&quot;=&gt;&quot;2em&quot;)/&gt;&quot;&quot;&quot;
#-&gt; &lt;div style=&#39;font-size: 25px;padding-left: 2em;&#39;/&gt;

@print htl&quot;&quot;&quot;&lt;div style=$(fontSize=&quot;25px&quot;,paddingLeft=&quot;2em&quot;)/&gt;&quot;&quot;&quot;
#-&gt; &lt;div style=&#39;font-size: 25px;padding-left: 2em;&#39;/&gt;</code></pre><p>Only symbols, numbers, and strings have a specified serialization as css style values. Therefore, use of components from other libraries will cause an exception.  However, this can be fixed by registering a conversion using <code>css_value()</code>.</p><pre><code class="language-julia">using Hyperscript

HypertextLiteral.css_value(x::Hyperscript.Unit) = string(x)</code></pre><p>Then, the syntax for CSS can be even more compact.</p><pre><code class="language-julia">@print htl&quot;&lt;div style=$(fontSize=25px,paddingLeft=2em)/&gt;&quot;
#-&gt; &lt;div style=&#39;font-size: 25px;padding-left: 2em;&#39;/&gt;</code></pre><p>For the <em>unquoted</em> <code>&quot;class&quot;</code> attribute, a <code>Vector</code> provides a space between each of the elements.</p><pre><code class="language-julia">@print @htl(&quot;&lt;div class=$([:one, :two])/&gt;&quot;)
#-&gt; &lt;div class=&#39;one two&#39;/&gt;

@print htl&quot;&lt;div class=$(:one, :two)/&gt;&quot;
#-&gt; &lt;div class=&#39;one two&#39;/&gt;</code></pre><h2 id="Custom-Extensions"><a class="docs-heading-anchor" href="#Custom-Extensions">Custom Extensions</a><a id="Custom-Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Extensions" title="Permalink"></a></h2><p>We&#39;ve seen our first extension, but it is specific to CSS. But how can we serialize a custom data object within an interpolated result? If one attempts to reference a user defined type, it will be an error.</p><pre><code class="language-julia">struct Custom data::String end

@print @htl &quot;$(Custom(&quot;a&amp;b&quot;))&lt;/tag&gt;&quot;
#-&gt; ERROR: MethodError: no method matching show(…&quot;text/html&quot;…Custom)⋮</code></pre><p>This can be addressed by implementing the <code>&quot;text/html&quot; mimetype in</code>Base.show<code>for the custom type in question. In this case, be sure to escape ampersand (</code>&amp;<code>) and less-than (</code>&lt;<code>). This could be done using</code>replace<code>or by using our</code>escape_content` method.</p><pre><code class="language-julia"> struct Custom data::String end

 using HypertextLiteral: escape_content

 function Base.show(io::IO, mime::MIME&quot;text/html&quot;, c::Custom)
     value = escape_content(c.data)
     print(io, &quot;&lt;custom&gt;$(value)&lt;/custom&gt;&quot;)
 end

 @print @htl(&quot;&lt;span&gt;$(Custom(&quot;a&amp;b&quot;))&lt;/span&gt;&quot;)
 #-&gt; &lt;span&gt;&lt;custom&gt;a&amp;amp;b&lt;/custom&gt;&lt;/span&gt;</code></pre><p>This approach of using <code>show(io, MIME&quot;text/html&quot;(), ...)</code> lets us support many other systems out of the box without needing any glue.</p><pre><code class="language-julia">using Hyperscript
@tags span

@print @htl(&quot;&lt;div&gt;$(span(&quot;Hello World&quot;))&lt;/div&gt;&quot;)
#-&gt; &lt;div&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;/div&gt;</code></pre><p>Displaying an object within an attribute...</p><pre><code class="language-julia">#TODO: show how this works here.</code></pre><p>It&#39;s also possible to let us know that your custom attribute uses boolean attribute treatment.</p><pre><code class="language-julia">import HypertextLiteral: is_boolean, Attribute

is_boolean(::Attribute{Symbol(&quot;my-att&quot;)}) = true

@print @htl(&quot;&lt;tag myAtt=$(false)/&gt;&quot;)
#-&gt; &lt;tag/&gt;</code></pre><p>So that the scope of objects serialized in this manner is clear, we don&#39;t permit adjacent unquoted values.</p><pre><code class="language-julia">htl&quot;&lt;tag bare=$(true)$(:invalid)&quot;
#=&gt;
ERROR: LoadError: DomainError with :invalid:
Unquoted attribute interpolation is limited to a single component⋮
=#</code></pre><p>To have a convenient notation, our string macro syntax interpolate tuples and generated expressions as concatenated output. This is currently not supported by <code>@htl</code> macro (see Julia ticket amp734).</p><pre><code class="language-julia">a = &quot;A&quot;
b = &quot;B&quot;

@print htl&quot;$(a,b)&quot;
#-&gt; AB

@print htl&quot;$(x for x in (a,b))&quot;
#-&gt; AB

@htl(&quot;$(x for x in (a,b))&quot;)
#-&gt; ERROR: syntax: invalid interpolation syntax</code></pre><p>While assignment operator is permitted in Julia string interpolation, we exclude it in both string literal and macro forms so to guard against accidentally forgetting the trailing comma for a 1-tuple.</p><pre><code class="language-julia">@print htl&quot;&quot;&quot;&lt;div $(dataValue=42,)/&gt;&quot;&quot;&quot;
#-&gt; &lt;div data-value=&#39;42&#39;/&gt;

htl&quot;&quot;&quot;&lt;div $(dataValue=42)/&gt;&quot;&quot;&quot;
#=&gt;
ERROR: LoadError: DomainError with dataValue = 42:
assignments are not permitted in an interpolation⋮
=#

@htl(&quot;&lt;div $(dataValue=42)/&gt;&quot;)
#=&gt;
ERROR: LoadError: DomainError with dataValue = 42:
assignments are not permitted in an interpolation⋮
=#</code></pre><p>Even though booleans are considered numeric in Julia, we treat them as an error to guard against quoted use in boolean HTML attributes.</p><pre><code class="language-julia">htl&quot;&lt;button checked=&#39;$(true)&#39;&quot;
#=&gt;
ERROR: DomainError with true:
The attribute &#39;checked&#39; is boolean, use unquoted attribute form.
=#</code></pre><h2 id="Quirks-and-Regression"><a class="docs-heading-anchor" href="#Quirks-and-Regression">Quirks &amp; Regression</a><a id="Quirks-and-Regression-1"></a><a class="docs-heading-anchor-permalink" href="#Quirks-and-Regression" title="Permalink"></a></h2><p>Since this string format uses Julia macro processing, there are some differences between an <code>htl</code> literal and native Julia interpolation. For starters, Julia doesn&#39;t recognize and treat <code>$</code> syntax natively for these macros, hence, at a very deep level parsing is different.</p><pre><code class="language-julia">&quot;$(&quot;Hello&quot;)&quot;
#-&gt; &quot;Hello&quot;</code></pre><p>In this interpolation, the expression <code>&quot;Hello&quot;</code> is seen as a string, and hence Julia can produce the above output. However, Julia does not given this special treatment to string literals. Hence, if you try this expression using <code>htl</code> you&#39;ll get an error.</p><pre><code class="language-julia">htl&quot;$(&quot;Hello&quot;)&quot;
#-&gt; ERROR: syntax: cannot juxtapose string literal</code></pre><p>The above expression is seen by Julia as 3 tokens, <code>htl&quot;$(&quot;</code>, followed by <code>Hello</code>, and then <code>&quot;)</code>. This combination is a syntax error. One might correct this using triple strings.</p><pre><code class="language-julia">#? VERSION &gt; v&quot;1.5.0&quot;
htl&quot;&quot;&quot;$(&quot;Hello&quot;)&quot;&quot;&quot;
#-&gt; htl&quot;$(\&quot;Hello\&quot;)&quot;</code></pre><p>Alternatively, in Julia v1.6+, one could use the <code>@htl</code> macro format for cases where there are string literals.</p><pre><code class="language-julia">#? VERSION &gt;= v&quot;1.6.0-DEV&quot;
@htl &quot;$(&quot;Hello&quot;)&quot;
#-&gt; @htl &quot;$(&quot;Hello&quot;)&quot;</code></pre><p>Before v1.6, we cannot reliably detect interpolated string literals using the <code>@htl</code> macro, so they are errors (when we can detect them).</p><pre><code class="language-julia">#? VERSION &lt; v&quot;1.6.0-DEV&quot;
@print @htl &quot;Look, Ma, $(&quot;&lt;i&gt;automatic escaping&lt;/i&gt;&quot;)!&quot;
#-&gt; ERROR: LoadError: &quot;interpolated string literals are not supported&quot;⋮</code></pre><p>However, you can fix by wrapping a value in a <code>string</code> function.</p><pre><code class="language-julia">@print @htl &quot;Look, Ma, $(string(&quot;&lt;i&gt;automatic escaping&lt;/i&gt;&quot;))!&quot;
#-&gt; Look, Ma, &amp;lt;i&gt;automatic escaping&amp;lt;/i&gt;!</code></pre><p>The string literal style is not without its quirks. See <code>@raw_str</code> for exceptional cases where a slash immediately precedes the double quote. This is one case where the <code>htl</code> string macro cannot be made to work in a manner identical to regular string interpolation.</p><pre><code class="language-julia">@print htl&quot;(\\\&quot;)&quot;
#-&gt; (&quot;)

@print @htl(&quot;(\\\&quot;)&quot;)
#-&gt; (\&quot;)</code></pre><p>In Julia, to support regular expressions and other formats, string literals don&#39;t provide regular escaping semantics. This package adds those semantics.</p><pre><code class="language-julia">htl&quot;Hello\World&quot;
#-&gt; ERROR: LoadError: ArgumentError: invalid escape sequence⋮

@htl &quot;Hello\World&quot;
#-&gt; ERROR: syntax: invalid escape sequence⋮</code></pre><p>Escaped strings should just pass-though.</p><pre><code class="language-julia">@print htl&quot;\&quot;\t\\&quot;
#-&gt; &quot;	\

@print @htl(&quot;\&quot;\t\\&quot;)
#-&gt; &quot;	\</code></pre><p>Within attributes, independent of quoting style, other datatypes are treated as an error. This includes <code>Vector</code> as well as <code>HTL</code> objects.</p><pre><code class="language-julia">htl&quot;&lt;tag att=&#39;$([1,2,3])&#39;&quot;
#-&gt; ERROR: MethodError: no method matching stringify⋮</code></pre><p>Symbols are also properly handled; e.g. escaping happens after conversion of numbers, symbols and custom types to strings.</p><pre><code class="language-julia">@print htl&quot;&quot;&quot;&lt;tag att=$(Symbol(&quot;&#39;&amp;&quot;))&gt;$(Symbol(&quot;&lt;&amp;&quot;))&lt;/tag&gt;&quot;&quot;&quot;
#-&gt; &lt;tag att=&#39;&amp;apos;&amp;amp;&#39;&gt;&amp;lt;&amp;amp;&lt;/tag&gt;</code></pre><p>Interpolation should handle splat operator by concatenating results.</p><pre><code class="language-julia">@print htl&quot;$([x for x in 1:3]...)&quot;
#-&gt; 123

@print @htl &quot;$([x for x in 1:3]...)&quot;
#-&gt; 123</code></pre><p>Within element content, we treat a <code>Vector</code> as a sequence to be containated.</p><pre><code class="language-julia">@print htl&quot;$([x for x in 1:3])&quot;
#-&gt; 123

@print @htl &quot;$([x for x in 1:3])&quot;
#-&gt; 123</code></pre><p>The <code>script</code> and <code>style</code> tags use a &quot;raw text&quot; encoding where all content up-to the end tag is not escaped using ampersands.</p><pre><code class="language-julia">book = &quot;Strunk &amp; White&quot;
@print htl&quot;&quot;&quot;&lt;script&gt;var book = &quot;$book&quot;&lt;/script&gt;&quot;&quot;&quot;
#-&gt; &lt;script&gt;var book = &quot;Strunk &amp; White&quot;&lt;/script&gt;</code></pre><p>We throw an error if the end tag is accidently included.</p><pre><code class="language-julia">bad = &quot;&lt;/style&gt;&quot;

htl&quot;&quot;&quot;&lt;style&gt;$bad&lt;/style&gt;&quot;&quot;&quot;
#=&gt;
ERROR: DomainError with &quot;&lt;/style&gt;&quot;:
  Content of &lt;style&gt; cannot contain the end tag (`&lt;/style&gt;`).
=#</code></pre><p>Attribute names should be non-empty and not in a list of excluded characters.</p><pre><code class="language-julia">@htl(&quot;&lt;tag $(&quot;&quot; =&gt; &quot;value&quot;)/&gt;&quot;)
#=&gt;
ERROR: DomainError with :
Attribute name must not be empty.
=#

@htl(&quot;&lt;tag $(&quot;&amp;att&quot; =&gt; &quot;value&quot;)/&gt;&quot;)
#=&gt;
ERROR: DomainError with &amp;att:
Invalid character (&#39;&amp;&#39;) found within an attribute name.
=#</code></pre><p>Unquoted interpolation adjacent to a raw string is also an error.</p><pre><code class="language-julia">htl&quot;&lt;tag bare=literal$(:invalid)&quot;
#=&gt;
ERROR: LoadError: DomainError with :invalid:
Unquoted attribute interpolation is limited to a single component⋮
=#

htl&quot;&lt;tag bare=$(invalid)literal&quot;
#=&gt;
ERROR: LoadError: DomainError with bare=literal:
Unquoted attribute interpolation is limited to a single component⋮
=#</code></pre><p>We limit string interpolation to symbols or parenthesized expressions. For more details on this see Julia #37817.</p><pre><code class="language-julia">htl&quot;$[1,2,3]&quot;
#=&gt;
ERROR: LoadError: DomainError with [1, 2, 3]:
interpolations must be symbols or parenthesized⋮
=#

@htl(&quot;$[1,2,3]&quot;)
#=&gt;
ERROR: syntax: invalid interpolation syntax: &quot;$[&quot;⋮
=#</code></pre><p>Before Julia v1.6 (see issue amp501), string literals should not be used within the macro style since we cannot reliably detect them.</p><pre><code class="language-julia">x = &quot;&quot;

@print htl&quot;&quot;&quot;$x$(&quot;&lt;script&gt;alert(&#39;Hello&#39;)&lt;/script&gt;&quot;)&quot;&quot;&quot;
#-&gt; &amp;lt;script&gt;alert(&#39;Hello&#39;)&amp;lt;/script&gt;

#? VERSION &gt;= v&quot;1.6.0-DEV&quot;
@print htl&quot;&quot;&quot;$x$(&quot;&lt;script&gt;alert(&#39;Hello&#39;)&lt;/script&gt;&quot;)&quot;&quot;&quot;
#-&gt; &amp;lt;script&gt;alert(&#39;Hello&#39;)&amp;lt;/script&gt;

#? VERSION &lt; v&quot;1.6.0-DEV&quot;
@print @htl(&quot;$x$(&quot;&lt;script&gt;alert(\&quot;Hello\&quot;)&lt;/script&gt;&quot;)&quot;)
#-&gt; &lt;script&gt;alert(&quot;Hello&quot;)&lt;/script&gt;</code></pre><p>Hence, for a cases where we could detect a string literal, we raise an error condition to discourage its use. The string macro form works.</p><pre><code class="language-julia">@print htl&quot;&quot;&quot;&lt;tag&gt;$(&quot;escape&amp;me&quot;)&lt;/tag&gt;&quot;&quot;&quot;
#-&gt; &lt;tag&gt;escape&amp;amp;me&lt;/tag&gt;

#? VERSION &gt;= v&quot;1.6.0-DEV&quot;
@print @htl &quot;&lt;tag&gt;$(&quot;escape&amp;me&quot;)&lt;/tag&gt;&quot;
#-&gt; &lt;tag&gt;escape&amp;amp;me&lt;/tag&gt;

#? VERSION &lt; v&quot;1.6.0-DEV&quot;
@print @htl &quot;&lt;tag&gt;$(&quot;escape&amp;me&quot;)&lt;/tag&gt;&quot;
#-&gt; ERROR: LoadError: &quot;interpolated string literals are not supported&quot;⋮</code></pre><p>A string ending with <code>$</code> is an syntax error since it is an incomplete interpolation.</p><pre><code class="language-julia">@print htl&quot;$&quot;
#-&gt; ERROR: LoadError: &quot;missing interpolation expression&quot;⋮

@print htl&quot;Foo$&quot;
#-&gt; ERROR: LoadError: &quot;missing interpolation expression&quot;⋮</code></pre><p>Here&#39;s something that perhaps should work... but fails currently.</p><pre><code class="language-julia"># htl&quot;&lt;div $(:dataValue=&gt;42, &quot;data-style&quot;=&gt;:green)/&gt;</code></pre><h2 id="Contributing"><a class="docs-heading-anchor" href="#Contributing">Contributing</a><a id="Contributing-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing" title="Permalink"></a></h2><p>We are absolutely open to suggested improvements. This package is implemented according to several design criteria.</p><ul><li><p>Operation of interpolated expressions (<code>$</code>) should mirror what they would do with regular Julia strings, updated with hypertext escaping sensibilities including proper escaping and helpful representations.</p></li><li><p>With exception of boolean attributes (which must be removed to be false), input is treated as-is and not otherwise modified.</p></li><li><p>Values having serialization to <code>&quot;text/html&quot;</code> are injected &quot;as-is&quot; into element content. Attributes should only accept string objects.</p></li><li><p>Given that this library will be used by content producers, it should be conservative, raising an error when invalid hypertext is discovered and only serializing Julia objects that have an express representation.</p></li><li><p>There should be an extension API that permits custom data types to provide their own context-sensitive serialization strategies.</p></li><li><p>As much processing (e.g. hypertext lexical analysis) should be done during macro expansion to reduce runtime and to report errors early. Error messages should guide the user towards addressing the problem.</p></li><li><p>To be helpful, HTML tags and attributes may be recognized. Special behavior may be provided to attributes such as <code>&quot;style&quot;</code> (CSS), <code>&quot;class&quot;</code> and, eventually, <code>&quot;script&quot;</code>.</p></li><li><p>Full coverage of HTML syntax is ideal, but unnecessary.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 12 December 2020 05:01">Saturday 12 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

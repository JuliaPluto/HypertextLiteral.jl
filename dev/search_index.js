var documenterSearchIndex = {"docs":
[{"location":"extend/#Integration","page":"Extend","title":"Integration","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"For hypertext content, Julia has a protocol to let independent libraries work together. For any object, one could ask if it is showable to displays supporting the \"text/html\" mimetype.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using HypertextLiteral\n\nmacro print(expr)\n    :(display(\"text/html\", $expr))\nend\n\nshowable(\"text/html\", @htl(\"<tag/>\"))\n#-> true","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"We use this protocol to integrate with third party tools, such as Hyperscript without introducing dependencies.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using Hyperscript\n@tags span div\n\n@print component = span(\"...\")\n#-> <span>...</span>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Since component is showable via \"text/html\", it can be integrated directly. Conversely, results of @htl interpolation can be included directly as a Hyperscript node.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"@print @htl(\"<div>$(span(\"...\"))</div>\")\n#-> <div><span>...</span></div>\n\n@print div(@htl(\"<span>...</span>\"))\n#-> <div><span>...</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Generally, any custom component can be enhanced to work directly with this and similar libraries by implementing show for \"text/html\". In this case, properly escaping concent is important.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Custom data::String end\n\nfunction Base.show(io::IO, mime::MIME\"text/html\", c::Custom)\n    value = replace(replace(c.data, \"&\"=>\"&amp;\"), \"<\"=>\"&lt;\")\n    print(io, \"<custom>$(value)</custom>\")\nend\n\n@print @htl(\"<span>$(Custom(\"a&b\"))</span>\")\n#-> <span><custom>a&amp;b</custom></span>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Conservatively, many more characters should be escaped, including both single (') and double (\") quotes. However, we shouldn't assume this.","category":"page"},{"location":"extend/#Attribute-Value-Context","page":"Extend","title":"Attribute Value Context","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"Unfortunately, there is no such protocol for attribute values, which have different escaping needs (single or double quote, respectively). Hence, integrating Hyperscript's CSS Unit object, such as 2em, isn't automatic. By default, a MethodError is raised.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"typeof(2em)\n#-> Hyperscript.Unit{:em, Int64}\n\n@print @htl(\"<div style=$((border=2em,))>...</div>\")\n#-> …ERROR: MethodError: no method matching attribute_value(…Unit{:em,⋮","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Letting objects of an unknown type work with @htl macros follows Julia's sensibilities, you implement attribute_value for that type.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"HypertextLiteral.attribute_value(x::Hyperscript.Unit) = x\n\n@print @htl(\"<div style=$((border=2em,))>...</div>\")\n#-> <div style='border: 2em;'>...</div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"This works as follows. When obj is encountered in an attribute context, attribute_value(obj) is called. Then, print() is called on the result to create a character stream. This stream is then escaped and included into the results. Let's do this with a Custom object.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Custom data::String end\n\nHypertextLiteral.attribute_value(x::Custom) = x.data\n\n@print @htl(\"<tag attribute=$(Custom(\"'A&B'\"))/>\")\n#-> <tag attribute='&apos;A&amp;B&apos;'/>","category":"page"},{"location":"extend/#Content-Context","page":"Extend","title":"Content Context","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"TODO: Discuss content extensions.","category":"page"},{"location":"extend/#Inside-Tag-Context","page":"Extend","title":"Inside Tag Context","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"TODO: Discuss inside_tag extensions.","category":"page"},{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"We are open to suggested improvements. This package is implemented according to several design criteria.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Operation of interpolated expressions ($) should (mostly) mirror what they would do with regular Julia strings, updated with hypertext escaping sensibilities including proper escaping.\nWith exception of boolean attributes (which must be removed to be false), input is treated as-is and not otherwise modified.\nProvide reasonable interpretation for Dict, Vector and other objects as attributes, element content, or attribute values.\nAs much processing (e.g. hypertext lexical analysis) should be done during macro expansion to reduce runtime and to report errors early. Error messages should guide the user towards addressing the problem.\nThere should be an extension API that permits custom data types to provide their own serialization strategies that are not dependent upon the namespace, element name, or attribute name.\nFull coverage of HTML syntax or reporting syntax or semantic errors within the HTML content is not a goal.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To discuss the design in more depth, let's restart our environment.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using HypertextLiteral\n\nmacro print(expr)\n    :(display(\"text/html\", $expr))\nend","category":"page"},{"location":"design/#Implementation-Notes","page":"Design","title":"Implementation Notes","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"So that the scope of objects serialized in this manner is clear, we don't permit adjacent unquoted values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"htl\"<tag bare=$(true)$(:invalid)\"\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To have a convenient notation, our string macro syntax interpolate tuples and generated expressions as concatenated output. This is currently not supported by @htl macro (see Julia ticket amp734).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"a = \"A\"\nb = \"B\"\n\n@print htl\"$(a,b)\"\n#-> AB\n\n@print htl\"$(x for x in (a,b))\"\n#-> AB\n\n@htl(\"$(x for x in (a,b))\")\n#-> ERROR: syntax: invalid interpolation syntax","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"While assignment operator is permitted in Julia string interpolation, we exclude it in both string literal and macro forms so to guard against accidentally forgetting the trailing comma for a 1-tuple.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"\"\"<div $(data_value=42,)/>\"\"\"\n#-> <div data-value='42'/>\n\nhtl\"\"\"<div $(data_value=42)/>\"\"\"\n#=>\nERROR: LoadError: DomainError with data_value = 42:\nassignments are not permitted in an interpolation⋮\n=#\n\n@htl(\"<div $(data_value=42)/>\")\n#=>\nERROR: LoadError: DomainError with data_value = 42:\nassignments are not permitted in an interpolation⋮\n=#","category":"page"},{"location":"design/#Quirks","page":"Design","title":"Quirks","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Since this string format uses Julia macro processing, there are some differences between an htl literal and native Julia interpolation. For starters, Julia doesn't recognize and treat $ syntax natively for these macros, hence, at a very deep level parsing is different.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"\"$(\"Hello\")\"\n#-> \"Hello\"","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"In this interpolation, the expression \"Hello\" is seen as a string, and hence Julia can produce the above output. However, Julia does not given this special treatment to string literals. Hence, if you try this expression using htl you'll get an error.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"htl\"$(\"Hello\")\"\n#-> ERROR: syntax: cannot juxtapose string literal","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The above expression is seen by Julia as 3 tokens, htl\"$(\", followed by Hello, and then \"). This combination is a syntax error. One might correct this using triple strings.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"#? VERSION > v\"1.5.0\"\nhtl\"\"\"$(\"Hello\")\"\"\"\n#-> htl\"$(\\\"Hello\\\")\"","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Alternatively, in Julia v1.6+, one could use the @htl macro format for cases where there are string literals.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"#? VERSION >= v\"1.6.0-DEV\"\n@htl \"$(\"Hello\")\"\n#-> @htl \"$(\"Hello\")\"","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Before v1.6, we cannot reliably detect interpolated string literals using the @htl macro, so they are errors (when we can detect them).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"#? VERSION < v\"1.6.0-DEV\"\n@print @htl \"Look, Ma, $(\"<i>automatic escaping</i>\")!\"\n#-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"However, you can fix by wrapping a value in a string function.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"Look, Ma, $(string(\"<i>automatic escaping</i>\"))!\"\n#-> Look, Ma, &lt;i>automatic escaping&lt;/i>!","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The string literal style is not without its quirks. See @raw_str for exceptional cases where a slash immediately precedes the double quote. This is one case where the htl string macro cannot be made to work in a manner identical to regular string interpolation.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"(\\\\\\\")\"\n#-> (\")\n\n@print @htl(\"(\\\\\\\")\")\n#-> (\\\")","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"This has tangible effect on expressions.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"print(@htl(\"$((\"<'\", \"\\\"&\"))\"))\n#-> &lt;&apos;&quot;&amp;\n\nprint(htl\"\"\"$((\"<'\", \"\\\\\"&\"))\"\"\")\n#-> &lt;&apos;&quot;&amp;","category":"page"},{"location":"design/#Regression-Tests","page":"Design","title":"Regression Tests","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"In Julia, to support regular expressions and other formats, string literals don't provide regular escaping semantics. This package adds those semantics.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"htl\"Hello\\World\"\n#-> ERROR: LoadError: ArgumentError: invalid escape sequence⋮\n\n@htl \"Hello\\World\"\n#-> ERROR: syntax: invalid escape sequence⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Escaped strings should just pass-though.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"\\\"\\t\\\\\"\n#-> \"\t\\\n\n@print @htl(\"\\\"\\t\\\\\")\n#-> \"\t\\","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Within attributes, Vector objects are serialized as space separated lists to support attributes such as class.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"<tag att='$([1,2,3])'/>\"\n#-> <tag att='1 2 3'/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Symbols are also propertly escaped.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"\"\"<tag att=$(Symbol(\"'&\"))>$(Symbol(\"<&\"))</tag>\"\"\"\n#-> <tag att='&apos;&amp;'>&lt;&amp;</tag>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Interpolation should handle splat operator by concatenating results.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"$([x for x in 1:3]...)\"\n#-> 123\n\n@print @htl \"$([x for x in 1:3]...)\"\n#-> 123","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Within element content, we treat a Vector as a sequence to be concatenated.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"$([x for x in 1:3])\"\n#-> 123\n\n@print @htl \"$([x for x in 1:3])\"\n#-> 123","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The script and style tags use a \"raw text\" encoding where all content up-to the end tag is not escaped using ampersands.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"book = \"Strunk & White\"\n@print htl\"\"\"<script>var book = \"$book\"</script>\"\"\"\n#-> <script>var book = \"Strunk & White\"</script>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We throw an error if the end tag is accidently included.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"bad = \"</style>\"\n\nhtl\"\"\"<style>$bad</style>\"\"\"\n#=>\nERROR: DomainError with \"</style>\":\n  Content of <style> cannot contain the end tag (`</style>`).\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Attribute names should be non-empty and not in a list of excluded characters.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $(\"\" => \"value\")/>\")\n#-> ERROR: LoadError: \"Attribute name must not be empty.\"⋮\n\n@print @htl(\"<tag $(\"&att\" => \"value\")/>\")\n#=>\nERROR: LoadError: DomainError with &att:\nInvalid character ('&') found within an attribute name.⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Unquoted interpolation adjacent to a raw string is also an error.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"htl\"<tag bare=literal$(:invalid)\"\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#\n\nhtl\"<tag bare=$(invalid)literal\"\n#=>\nERROR: LoadError: DomainError with bare=literal:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We limit string interpolation to symbols or parenthesized expressions. For more details on this see Julia #37817.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"htl\"$[1,2,3]\"\n#=>\nERROR: LoadError: DomainError with [1, 2, 3]:\ninterpolations must be symbols or parenthesized⋮\n=#\n\n@htl(\"$[1,2,3]\")\n#=>\nERROR: syntax: invalid interpolation syntax: \"$[\"⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Before Julia v1.6, string literals should not be used within the macro style since we cannot reliably detect them.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"\"\n\n@print htl\"\"\"$x$(\"<script>alert('Hello')</script>\")\"\"\"\n#-> &lt;script>alert(&apos;Hello&apos;)&lt;/script>\n\n#? VERSION >= v\"1.6.0-DEV\"\n@print htl\"\"\"$x$(\"<script>alert('Hello')</script>\")\"\"\"\n#-> &lt;script>alert(&apos;Hello&apos;)&lt;/script>\n\n#? VERSION < v\"1.6.0-DEV\"\n@print @htl(\"$x$(\"<script>alert(\\\"Hello\\\")</script>\")\")\n#-> <script>alert(\"Hello\")</script>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Hence, for a cases where we could detect a string literal, we raise an error condition to discourage its use. The string macro form works.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"\"\"<tag>$(\"escape&me\")</tag>\"\"\"\n#-> <tag>escape&amp;me</tag>\n\n#? VERSION >= v\"1.6.0-DEV\"\n@print @htl \"<tag>$(\"escape&me\")</tag>\"\n#-> <tag>escape&amp;me</tag>\n\n#? VERSION < v\"1.6.0-DEV\"\n@print @htl \"<tag>$(\"escape&me\")</tag>\"\n#-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A string ending with $ is an syntax error since it is an incomplete interpolation.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print htl\"$\"\n#-> ERROR: LoadError: \"missing interpolation expression\"⋮\n\n@print htl\"Foo$\"\n#-> ERROR: LoadError: \"missing interpolation expression\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Here's something that perhaps should work... but fails currently.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"# htl\"<div $(:dataValue=>42, \"data-style\"=>:green)/>","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [HypertextLiteral]\nPrivate = true","category":"page"},{"location":"reference/#HypertextLiteral.HypertextLiteral","page":"Reference","title":"HypertextLiteral.HypertextLiteral","text":"HypertextLiteral\n\nThis library provides for a @htl() macro and a htl string literal, both implementing interpolation that is aware of hypertext escape context. The @htl macro has the advantage of using Julia's native string parsing, so that it can handle arbitrarily deep nesting. However, it is a more verbose than the htl string literal and doesn't permit interpolated string literals. Conversely, the htl string literal, @htl_str, uses custom parsing letting it handle string literal escaping, however, it can only be used two levels deep (using three quotes for the outer nesting, and a single double quote for the inner).\n\n\n\n\n\n","category":"module"},{"location":"reference/#HypertextLiteral.EscapeProxy","page":"Reference","title":"HypertextLiteral.EscapeProxy","text":"EscapeProxy(io) - wrap an `io` to perform HTML escaping\n\nThis is a transparent proxy that performs HTML escaping so that objects that are printed are properly converted into valid HTML values.  As a special case, HTML objects are not escaped, hence, they could be used to bypass this proxy. At this time, it only supports & and < escaping. \n\nExamples\n\njulia> ep = EscapeProxy(stdout);\njulia> print(ep, \"A&B\")\nA&amp;B\njulia> print(ep, HTML(\"<tag/>\"))\n<tag/>\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Result","page":"Reference","title":"HypertextLiteral.Result","text":"Result(expr, unwrap)\n\nAddress display modalities by showing the macro expression that generated the results when shown on the REPL. However, when used with print() show the results. This object is also showable to any IO stream via \"text/html\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.UnwrapHTML","page":"Reference","title":"HypertextLiteral.UnwrapHTML","text":"UnwrapHTML(data) - delegate regular printing to text/html\n\nThis is the inverse wrapper to Docs.HTML – instead of enabling regular objects to be printed as MIME\"text/html\" it unwraps an HTML or any other object showable as text/html to be printable. Conversely, it will cause an error if that object is not showable as text/html.\n\nExamples\n\njulia> print(UnwrapHTML(HTML(\"Hello World\")))\nHello World\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.attribute_value-Tuple{AbstractString}","page":"Reference","title":"HypertextLiteral.attribute_value","text":"attribute_value(x)\n\nThis method may be implemented to specify a printed representation suitable for use within a quoted attribute value. By default, the print representation of an object is used, and then propertly escaped. There are a few overrides that we provide.\n\nThe elements of a Tuple or AbstractArray object are printed, with a space between each item.\nThe Pair, NamedTuple, and Dict objects are treated as if they are CSS style elements, with a colon between key and value, each pair delimited by a semi-colon.\nThe Bool object, which has special treatment for bare inside_tag, is an error when used within a quoted attribute.\n\nIf an object is wrapped with HTML then it is included in the quoted attribute value as-is, without inspection or escaping.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.content-Tuple{Any}","page":"Reference","title":"HypertextLiteral.content","text":"content(x)\n\nThis method may be implemented to specify a printed representation suitable for text/html output. As a special case, if the result is wrapped with HTML, then it is passed along as-is. Otherwise, the print representation of the resulting value is escaped. By default AbstractString, Number and Symbol values are printed and escaped. The elements of Tuple and AbstractArray are concatinated and then escaped. If a method is not implemented for a given object, then we attempt to show it via MIME\"text/html\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.inside_tag-Tuple{Pair}","page":"Reference","title":"HypertextLiteral.inside_tag","text":"inside_tag(value)\n\nConvert Julian object into a serialization of attribute pairs, showable via MIME\"text/html\". The default implementation of this delegates value construction of each pair to attribute_pair().\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.interpolate-Tuple{Any,Any}","page":"Reference","title":"HypertextLiteral.interpolate","text":"interpolate(args, this)::Expr\n\nTake an interweaved set of Julia expressions and strings, tokenize the strings according to the HTML specification [1], wrapping the expressions with wrappers based upon the escaping context, and returning an expression that combines the result with an Result wrapper.\n\nFor these purposes, a Symbol is treated as an expression to be resolved; while a String is treated as a literal string that won't be escaped. Critically, interpolated strings to be escaped are represented as an Expr with head of :string.\n\nThere are tags, \"script\" and \"style\" which are rawtext, in these cases there is no escaping, and instead raise an exception if the appropriate ending tag is in substituted content.\n\n[1] https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.normalize_attribute_name-Tuple{Symbol}","page":"Reference","title":"HypertextLiteral.normalize_attribute_name","text":"normalize_attribute_name(name)::String\n\nFor String names, this simply verifies that they pass the attribute name production, but are otherwise untouched.\n\nFor Symbol names, this converts snake_case Symbol objects to their kebab-case equivalent. So that keywords, such as for could be used, we strip leading underscores.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.rawtext-Tuple{Symbol,AbstractString}","page":"Reference","title":"HypertextLiteral.rawtext","text":"rawtext(context, value)\n\nWrap a string value that occurs with RAWTEXT, SCRIPT and other element context so that it is showable(\"text/html\"). The default implementation ensures that the given value doesn't contain substrings illegal for the given context.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.rewrite_inside_tag-Tuple{Any}","page":"Reference","title":"HypertextLiteral.rewrite_inside_tag","text":"rewrite_inside_tag(expr)\n\nAttempt to speed up serialization of inside_tag by exploring the expression tree at macro expansion time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.@htl-Tuple{Any}","page":"Reference","title":"HypertextLiteral.@htl","text":"@htl string-expression\n\nCreate a Result object with string interpolation ($) that uses context-sensitive hypertext escaping. Before Julia 1.6, interpolated string literals, e.g. $(\"Strunk & White\"), are treated as errors since they cannot be reliably detected (see Julia issue #38501).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#HypertextLiteral.@htl_str-Tuple{String}","page":"Reference","title":"HypertextLiteral.@htl_str","text":"@htl_str -> Result\n\nCreate a Result object with string interpolation ($) that uses context-sensitive hypertext escaping. Escape sequences should work identically to Julia strings, except in cases where a slash immediately precedes the double quote (see @raw_str and Julia issue #22926).\n\nInterpolation is extended beyond regular Julia strings to handle three additional cases: tuples, named tuples (for attributes), and generators. See Julia #38734 for the feature request so that this could also work within the @htl macro syntax.\n\n\n\n\n\n","category":"macro"},{"location":"#Introduction","page":"Usage","title":"Introduction","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"This package provides a Julia string literal, htl, and equivalent macro, @htl, that construct an object that could be rendered to MIME\"text/html\" displays. These macros support interpolation sensible to the needs of HTML generation.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"using HypertextLiteral","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"When printed directly to the console (via show), the output of these macros reproduce a verified expression that generated them.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"name = \"World\"\n\nhtl\"<span>Hello $name</span>\"\n#-> htl\"<span>Hello $name</span>\"\n\n@htl(\"<span>Hello $name</span>\")\n#-> @htl \"<span>Hello $(name)</span>\"","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"When displayed to \"text/html\" the evaluation is shown.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"name = \"World\"\n\ndisplay(\"text/html\", htl\"<span>Hello $name</span>\")\n#-> <span>Hello World</span>\n\ndisplay(\"text/html\", @htl(\"<span>Hello $name</span>\"))\n#-> <span>Hello World</span>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"We use NarrativeTest.jl to ensure our examples are correct. After each command is a comment with the expected output. To enhance readability, we'll also use the following macro.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"macro print(expr)\n    :(display(\"text/html\", $expr))\nend\n\n@print htl\"<span>Hello World</span>\"\n#-> <span>Hello World</span>\n\n@print @htl(\"<span>Hello World</span>\")\n#-> <span>Hello World</span>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Throughout this tutorial, we'll mostly stick with the macro form since it has better syntax highlighting support, however, the string literal form works (almost) equivalently (and is a tad shorter).","category":"page"},{"location":"#Content-Interpolation","page":"Usage","title":"Content Interpolation","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"Hypertext literal provides interpolation via $. Within content, the ampersand (&), less-than (<), single-quote (') and double-quote (\") are escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"book = \"Strunk & White\"\n\n@print @htl(\"<span>Today's Reading: $book</span>\")\n#-> <span>Today's Reading: Strunk &amp; White</span>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"To include a literal $ in the output, use \\$ as one would in a regular Julia string. Other escape sequences, such as \\\" also work.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"They said, \\\"your total is \\$42.50\\\".\")\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Within triple quotes, single quoted strings can go unescaped, however, we still need to escape the dollar sign ($).","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"\"\"They said, \"your total is \\$42.50\".\"\"\")\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Julia results can be interpolated using the $(expr) notation. Strings, numeric values (including Bool) and symbols are supported.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"2+2 = $(2+2)\")\n#-> 2+2 = 4\n\n@print @htl(\"<bool>$(false)</bool><sym>$(:sym)</sym>\")\n#-> <bool>false</bool><sym>sym</sym>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Functions returning objects created by this macro are not further escaped, permitting us to build reusable HTML templates.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"sq(x) = @htl(\"<span>$(x*x)</span>\")\n\n@print @htl(\"<div>3^2 is $(sq(3))</div>\")\n#-> <div>3^2 is <span>9</span></div>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Content generated by these macros can be nested. Within element content, vectors are automatically expanded. By default, arrays and tuples are enumerated, printing each of their values.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"books = [\"Who Gets What & Why\", \"Switch\", \"Governing The Commons\"]\n\n@print @htl(\"<ul>$([@htl(\"<li>$b\") for b in books])</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#\n\n@print @htl(\"<ul>$(map(books) do b @htl(\"<li>$b\") end)</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"#Attribute-Interpolation","page":"Usage","title":"Attribute Interpolation","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"Interpolation within single and double quoted attribute values are supported. Regardless of context, all four characters are escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"qval = \"\\\"&'\"\n\n@print @htl(\"\"\"<tag double=\"$qval\" single='$qval' />\"\"\")\n#-> <tag double=\"&quot;&amp;&apos;\" single='&quot;&amp;&apos;' />","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Unquoted or bare attributes are also supported. These are serialized using the single quoted style so that spaces and other characters do not need to be escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"arg = \"book='Strunk & White'\"\n\n@print @htl(\"<tag bare=$arg />\")\n#-> <tag bare='book=&apos;Strunk &amp; White&apos;' />","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Attributes may also be provided by any combination of dictionaries, named tuples, and pairs. Attribute names are normalized, where snake_case becomes kebab-case. We do not convert camelCase due to XML (MathML and SVG) attribute case sensitivity. Moreover, String attribute names are passed along as-is.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":" attributes = Dict(:data_style => :green, \"data_value\" => 42, )\n\n @print @htl(\"<div $attributes/>\")\n #-> <div data-style='green' data_value='42'/>\n\n @print @htl(\"<div $(:data_style=>:green) $(:dataValue=>42)/>\")\n #-> <div data-style='green' dataValue='42'/>\n\n @print @htl(\"<div $((:data_style=>:green, \"data_value\"=>42))/>\")\n #-> <div data-style='green' data_value='42'/>\n\n @print @htl(\"<div $((data_style=:green, dataValue=42))/>\")\n #-> <div data-style='green' dataValue='42'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"As you can see from this example, symbols and numbers (but not boolean values) are automatically printed within attributes. This interpolation works within quoted values as well.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"\"\"<tag numeric=\"$(0)\" symbol='$(:sym)'/>\"\"\")\n#-> <tag numeric=\"0\" symbol='sym'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Within bare attributes, boolean values provide special support for boolean HTML properties, such as \"disabled\". When a bare value false then the attribute is removed. When the value is true then the attribute is kept, with value being an empty string ('').","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<button checked=$(true) disabled=$(false)>\")\n#-> <button checked=''>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Since boolean values are given special treatment, they become an error within quoted attribute values. At this time, this behavior is universal and does not depend upon the exact attribute used.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<button disabled='$(false)'>\")\n#-> ERROR: \"Boolean used within a quoted attribute.\"⋮","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"In HTML, many attributes specify values with space-delimited tokens, such as the Cascading Style Sheet (CSS) \"class\" attribute. To support these attributes, arrays and tuples produce space delimited output.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<div class=$([:one, :two])/>\")\n#-> <div class='one two'/>\n\n@print htl\"<div class=$(:one, :two)/>\"\n#-> <div class='one two'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"To support nested key/value structures, such as the CSS \"style\" attribute, we have specialized expansion of dictionary like objects. For each pair, keys are separated from their value with a colon :, moreover, pairs are delimited by the semi-colon (;). Like attributes, snake_case is converted to kebab-case.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"header_styles = Dict(:font_size => \"25px\", \"padding-left\" => \"2em\")\n\n@print @htl(\"<div style=$header_styles/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@print @htl(\"<div style=$((:font_size=>\"25px\",\"padding-left\"=>\"2em\"))/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@print @htl(\"<div style=$((font_size=\"25px\", padding_left=\"2em\"))/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>","category":"page"},{"location":"utils/#Utility-Classes","page":"Utilities","title":"Utility Classes","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This is a regression test for components upon which HTL is constructed.","category":"page"},{"location":"utils/#UnwrapHTML","page":"Utilities","title":"UnwrapHTML","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This utility class acts as the inverse of HTML.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"using HypertextLiteral: UnwrapHTML\n\nprint(UnwrapHTML(HTML(\"Hello World\")))\n#-> Hello World\n\ndisplay(\"text/html\", UnwrapHTML(HTML(\"Hello World\")))\n#-> Hello World\n\ndisplay(\"text/html\", UnwrapHTML(UnwrapHTML(HTML(\"Hello World\"))))\n#-> Hello World\n\nprint(UnwrapHTML(HTML(\"Hello \"), HTML(\"World\")))\n#-> Hello World\n\ndisplay(\"text/html\", UnwrapHTML(HTML(\"Hello \"), HTML(\"World\")))\n#-> Hello World\n\nprint(UnwrapHTML(\"This is an error!\"))\n#-> ERROR: MethodError: … show(… ::MIME{Symbol(\"text/html\")}⋮\n\nprint(UnwrapHTML(\"Error\", HTML(\"Good\")))\n#-> ERROR: MethodError: … show(… ::MIME{Symbol(\"text/html\")}⋮","category":"page"},{"location":"utils/#EscapeProxy","page":"Utilities","title":"EscapeProxy","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This utility class acts wraps an IO stream to provide HTML escaping.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"using HypertextLiteral: EscapeProxy\n\nio = IOBuffer()\nep = EscapeProxy(io)\n\nmacro echo(expr)\n    :($expr; print(String(take!(io))))\nend","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"The result of this proxy is that regular content is escaped. We also use HTML as a way to bypass this proxy.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"@echo print(ep, \"(&'<\\\")\")\n#-> (&amp;&apos;&lt;&quot;)\n\n@echo print(ep, HTML(\"<span>\"), \"<A&B>\", HTML(\"</span>\"))\n#-> <span>&lt;A&amp;B></span>","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Let's suppose someone has written a Custom object.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"struct Custom\n    content\nend\n\nCustom(\"<tag/>\")\n#-> Custom(\"<tag/>\")","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"If we print this though the escape proxy, we'll get the escaped representation of the above string value.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"@echo print(ep, Custom(\"<tag/>\"))\n#-> …Custom(&quot;&lt;tag/>&quot;)","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"We can address this with two parts. First, we can ensure this object is showable for \"text/html\". Second, we need to wrap this object so that the escape proxy knows to invoke this method.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Base.show(io::IO, m::MIME\"text/html\", c::Custom) =\n   print(io, c.content)\n\n@echo print(ep, UnwrapHTML(Custom(\"<tag/>\")))\n#-> <tag/>","category":"page"}]
}

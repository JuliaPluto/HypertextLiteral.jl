var documenterSearchIndex = {"docs":
[{"location":"extend/#Integration","page":"Extend","title":"Integration","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"For hypertext content, Julia has a protocol to let independent libraries work together. For any object, one could ask if it is showable to displays supporting the \"text/html\" mimetype.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using HypertextLiteral\n\nmacro print(expr)\n    :(display(\"text/html\", $expr))\nend\n\nshowable(\"text/html\", @htl(\"<tag/>\"))\n#-> true","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"We use this protocol to integrate with third party tools, such as Hyperscript without introducing dependencies.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using Hyperscript\n@tags span div\n\n@print component = span(\"...\")\n#-> <span>...</span>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Since component is showable via \"text/html\", it can be integrated directly. Conversely, results of @htl interpolation can be included directly as a Hyperscript node.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"@print @htl(\"<div>$(span(\"...\"))</div>\")\n#-> <div><span>...</span></div>\n\n@print div(@htl(\"<span>...</span>\"))\n#-> <div><span>...</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Any datatype can be enhanced to work directly with this and similar libraries by implementing show for \"text/html\". In this case, properly escaping content is important.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Showable data::String end\n\nfunction Base.show(io::IO, mime::MIME\"text/html\", c::Showable)\n    value = replace(replace(c.data, \"&\"=>\"&amp;\"), \"<\"=>\"&lt;\")\n    print(io, \"<showable>$(value)</showable>\")\nend\n\n@print @htl(\"<span>$(Showable(\"a&b\"))</span>\")\n#-> <span><showable>a&amp;b</showable></span>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"If the type of a value is not showable as \"text/html\", a function is generated that prints the value, escapes the output, placed inside a <span> tag using the type's name as the class attribute.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct NotShowable data::String; end\n\nBase.print(io::IO, c::NotShowable) = print(io, c.data)\n\n@print @htl(\"<div>$(NotShowable(\"a&b\"))</div>\")\n#-> <div><span class=\"NotShowable\">a&amp;b</span></div>","category":"page"},{"location":"extend/#Content-Extensions","page":"Extend","title":"Content Extensions","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"Sometimes it's useful to extend @htl so that it knows how to print your object without implementing show for \"text/html\" this can be done by implementing a method for the content() function.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Custom data::String end\n\nHypertextLiteral.content(c::Custom) = \"They said: '$(c.data)'\"\n\n@print @htl(\"<span>$(Custom(\"Hello\"))</span>\")\n#-> <span>They said: &apos;Hello&apos;</span>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"By default, the result of the content() is fully escaped, in this way you don't have to worry about implement one's own escaping. If your custom object is building tagged content, you can bypass escaping.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"HypertextLiteral.content(c::Custom) =\n    HypertextLiteral.Bypass(\"<span>$(c.data)</span>\")\n\n@print @htl(\"<div>$(Custom(\"Hello\"))</div>\")\n#-> <div><span>Hello</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Unfortunately, this won't encode the argument to your object.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"@print @htl(\"<div>$(Custom(\"<script>alert('whoops!);\"))</div>\")\n#-> <div><span><script>alert('whoops!);</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"This can be addressed with Reprint. In this case, the value you return is a functor (and object holding a function) built by Reprint.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using HypertextLiteral: Bypass, Reprint\n\nHypertextLiteral.content(c::Custom) =\n    Reprint(io::IO -> begin\n        print(io, Bypass(\"<span>\"))\n        print(io, c.data)\n        print(io, Bypass(\"</span>\"))\n    end)\n\n@print @htl(\"<div>$(Custom(\"a&b\"))</div>\")\n#-> <div><span>a&amp;b</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"This is essentially what @htl macro produces.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"HypertextLiteral.content(c::Custom) =\n    @htl(\"<span>$(c.data)</span>\")\n\n@print @htl(\"<div>$(Custom(\"a&b\"))</div>\")\n#-> <div><span>a&amp;b</span></div>","category":"page"},{"location":"extend/#Attribute-Value-Context","page":"Extend","title":"Attribute Value Context","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"Unlike content which has a show \"text/html\" fallback, there is not a suitable mime type for attribute values. By default, we use the print method of the object in this context.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"typeof(2em)\n#-> Hyperscript.Unit{:em, Int64}\n\n@print @htl(\"<div style=$((border=2em,))>...</div>\")\n#-> <div style='border: 2em;'>...</div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"However, this isn't always desirable. Often in Julia the default print representation of an object is what you could use to reconstruct the object on the REPL.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Custom data::String end\n\nprint(Custom(\"A&B\"))\n#-> …Custom(\"A&B\")","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"However, this is less than desireable in your HTML output.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"@print @htl(\"<tag att=$(Custom(\"A&B\"))/>\")\n#-> <tag att='…Custom(&quot;A&amp;B&quot;)'/>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"This can be addressed by overriding attribute_value.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"HypertextLiteral.attribute_value(x::Custom) = x.data\n\n@print @htl(\"<tag att=$(Custom(\"A&B\"))/>\")\n#-> <tag att='A&amp;B'/>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Like content above, Bypass and Reprint work identically.","category":"page"},{"location":"extend/#Inside-Tag-Context","page":"Extend","title":"Inside Tag Context","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"In some important cases one wishes to expand a Julia object into a set of attributes. This can be done by implementing insidetag(). At this point, it's better to study the implementation in convert.jl. Here is an example.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using HypertextLiteral: attribute_pair\n\nstruct CustomCSS class::Vector{Symbol}; style end\n\nHypertextLiteral.inside_tag(s::CustomCSS) = begin\n    myclass = join((string(x) for x in s.class), \" \")\n    Reprint() do io::IO\n        print(io, attribute_pair(:class, myclass))\n        print(io, attribute_pair(:style, s.style))\n    end\nend\n\nstyle = CustomCSS([:one, :two], :background_color => \"#92a8d1\")\n\n@print @htl(\"<div $style>Hello</div>\")\n#-> <div class='one two' style='background-color: #92a8d1;'>Hello</div>\nstruct Custom data::String end\n\nfunction Base.show(io::IO, mime::MIME\"text/javascript\", c::Custom)\n    print(io, c)\nend","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"There is a small ecosystem of methods to implement the expansion of Dict, Pair, NamedTuple, Vector, Tuple and Base.Generator in multiple contexts. They could be reused or just ignored.","category":"page"},{"location":"extend/#Script-Context","page":"Extend","title":"Script Context","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"Within the script tag, content is not \"text/html\", instead, it is treated as \"text/javascript\". Custom objects which are showable as \"text/javascript\" can be printed without any escaping in this context.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Log\n    data\nend\n\nfunction Base.show(io::IO, mime::MIME\"text/javascript\", c::Log)\n    print(io, \"console.log(\", c.data, \")\")\nend\n\n@print @htl(\"\"\"<script>$(Log(\"undefined\"))</script>\"\"\")\n#-> <script>console.log(undefined)</script>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Alternatively, one could implement print_script to provide a representation for this context.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"import HypertextLiteral: print_script\n\nfunction print_script(io::IO, c::Log)\n    print(io, \"console.log(\")\n    print_script(io, c.data)\n    print(io, \")\")\nend\n\n@print @htl(\"\"\"<script>$(Log(nothing))</script>\"\"\")\n#-> <script>console.log(undefined)</script>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"This content must not only be valid Javascript, but also escaped so that <script>, </script>, and <!-- literal values do not appear. When using print_script this work is performed automatically.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"content = \"\"\"<script>alert(\"hello\")</script>\"\"\"\n\n@print @htl(\"<script>$(Log(content))</script>\")\n#-> <script>console.log(\"<\\script>alert(\\\"hello\\\")<\\/script>\")</script>","category":"page"},{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"This package is implemented according to several design criteria.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Operation of interpolated expressions ($) should (mostly) mirror what they would do with regular Julia strings, updated with hypertext escaping sensibilities including proper escaping.\nSpeed of construction is critically important. This library is intended to be used deep within systems that generate extensive number of very large reports, interactively or in batch.\nWith exception of boolean attributes (which must be removed to be false), input is treated as-is and not otherwise modified.\nProvide reasonable interpretation for Dict, Vector and other objects as element content, attributes, and attribute value\nProvide direct support for script and style rawtext elements, which have their own interpolation needs.\nSince the style and class attributes are so important in HTML construction, universal interpretations of Julia constructs should make sense to aid these CSS attributes.\nThere should be a discoverable and well documented extension API that permits custom data types to provide their own serialization strategies based upon syntactical context.\nAs much processing (e.g. hypertext lexical analysis) should be done during macro expansion to reduce runtime and to report errors early. We'll be slightly slower on interactive use to be fast in batch.\nFull coverage of HTML syntax or reporting syntax or semantic errors within the HTML content is not a goal.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To discuss the design in more depth, let's restart our environment.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using HypertextLiteral\n\nmacro print(expr)\n    :(display(\"text/html\", $expr))\nend","category":"page"},{"location":"design/#Specific-Design-Decisions","page":"Design","title":"Specific Design Decisions","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Objects created by @htl are lazily constructed. What do we show on the REPL? We decided to parrot back the macro expression.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"Hello World\"\n\"Hello World\"\n\n@htl(\"<span>$x</span>\")\n#-> @htl \"<span>$(x)</span>\"","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"You could use the print command to evaluate the expression, showing the \"text/html\" results.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"Hello World\"\n\"Hello World\"\n\nprint(@htl(\"<span>$x</span>\"))\n#-> <span>Hello World</span>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We wrap missing and other data types using a <span> tag as they are printed. This permits customized CSS to control their presentation.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"\"\"<tag>$(missing)</tag>\"\"\")\n#-> <tag><span class=\"Base-Missing\">missing</span></tag>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"So that the scope of objects serialized in this manner is clear, we don't permit adjacent unquoted values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"<tag bare=$(true)$(:invalid)\")\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"While assignment operator is permitted in Julia string interpolation, we exclude it to guard it against accidently forgetting a comma.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<div $((data_value=42,))/>\")\n#-> <div data-value='42'/>\n\n@htl(\"<div $((data_value=42))/>\")\n#=>\nERROR: LoadError: DomainError with data_value = 42:\nassignments are not permitted in an interpolation⋮\n=#\n\n@htl(\"<div $(data_value=42)/>\")\n#=>\nERROR: LoadError: DomainError with data_value = 42:\nassignments are not permitted in an interpolation⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Symbols and Numeric values are properly escaped. While it is perhaps faster to assume all Symbol and Number objects could never contain invalid characters, we don't make this assumption.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"\"\"<tag att=$(Symbol(\"'&\"))>$(Symbol(\"<&\"))</tag>\"\"\")\n#-> <tag att='&apos;&amp;'>&lt;&amp;</tag>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Julia's regular interpolation stringifies everything. We don't do that we treat a Vector as a sequence to be concatenated. Moreover, we let the interpretation be customized though an extensive API.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"$([x for x in 1:3])\"\n#-> 123","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Since Julia's regular string interpolation works with the splat operator, we implement this as well, by concatenating results.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"$([x for x in 1:3]...)\"\n#-> 123","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Observe that map() is currently the most performant way to loop.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"$(map(1:3) do x; x; end)\"\n#-> 123","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Interpolation within the xmp, iframe, noembed, noframes, and noscript tags are not supported.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"\"\"<xmp>$var</xmp>\"\"\")\n#=>\nERROR: LoadError: DomainError with xmp:\nOnly script and style rawtext tags are supported.⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The script and style tag are not permitted to include their end tag.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"bad = \"</style>\"\n\n@print @htl(\"\"\"<style>$bad</style>\"\"\")\n#-> …ERROR: \"Content within a style tag must not contain `</style>`\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Interpolation within a style tag is converted like attribute values, only that amperstand escaping is not used.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<style> $(3) $(true) $(:sym) </style>\")\n#-> <style> 3 true sym </style>","category":"page"},{"location":"design/#Detection-of-String-Literals","page":"Design","title":"Detection of String Literals","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Before v1.6, we cannot reliably detect string literals using the @htl macro, so they are errors (when we can detect them).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"#? VERSION < v\"1.6.0-DEV\"\n@print @htl \"Look, Ma, $(\"<i>automatic escaping</i>\")!\"\n#-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"g     #? VERSION < v\"1.6.0-DEV\"     @print @htl \"even if they are the only content\"     #-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"However, you can fix by wrapping a value in a string function.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"Look, Ma, $(string(\"<i>automatic escaping</i>\"))!\"\n#-> Look, Ma, &lt;i>automatic escaping&lt;/i>!","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"In particular, there are edge cases where unescaped string literal content can leak.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"\"\n\n#? VERSION < v\"1.6.0-DEV\"\n@print @htl(\"$x$(\"<script>alert(\\\"Hello\\\")</script>\")\")\n#-> <script>alert(\"Hello\")</script>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Julia #38501 was fixed in v1.6.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"#? VERSION >= v\"1.6.0-DEV\"\n@print @htl \"<tag>$(\"escape&me\")</tag>\"\n#-> <tag>escape&amp;me</tag>","category":"page"},{"location":"design/#Regression-Tests","page":"Design","title":"Regression Tests","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Escaped strings are handled by @htl as one might expect.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"\\\"\\t\\\\\")\n#-> \"\t\\\n\n@print @htl(\"(\\\\\\\")\")\n#-> (\\\")","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Attribute names should be non-empty and not in a list of excluded characters.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $(\"\" => \"value\")/>\")\n#-> ERROR: LoadError: \"Attribute name must not be empty.\"⋮\n\n@print @htl(\"<tag $(\"&att\" => \"value\")/>\")\n#=>\nERROR: LoadError: DomainError with &att:\nInvalid character ('&') found within an attribute name.⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Unquoted interpolation adjacent to a raw string is also an error.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"<tag bare=literal$(:invalid)\")\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#\n\n@htl(\"<tag bare=$(invalid)literal\")\n#=>\nERROR: LoadError: DomainError with bare=literal:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"String interpolation is limited to symbols or parenthesized expressions. For more details on this see Julia #37817.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"$[1,2,3]\")\n#=>\nERROR: syntax: invalid interpolation syntax: \"$[\"⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Literal content can contain Unicode values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"Hello\"\n\n@print @htl(\"⁅$(x)⁆\")\n#-> ⁅Hello⁆","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Escaped content may also contain Unicode.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"⁅Hello⁆\"\n\n@print @htl(\"<tag>$x</tag>\")\n#-> <tag>⁅Hello⁆</tag>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Ensure that dictionary style objects are serialized. See issue #7.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"let\n    h = @htl(\"<div style=$(Dict(\"color\" => \"red\"))>asdf</div>\")\n    repr(MIME\"text/html\"(), h)\nend\n#-> \"<div style='color: red;'>asdf</div>\"","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Let's ensure that attribute values in a dictionary are escaped.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag escaped=$(Dict(:esc=>\"'&\\\"<\"))/>\")\n#-> <tag escaped='esc: &apos;&amp;&quot;&lt;;'/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Let's ensure that attribute values in a dictionary are escaped.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag escaped=$(Dict(:esc=>\"'&\\\"<\"))/>\")\n#-> <tag escaped='esc: &apos;&amp;&quot;&lt;;'/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Within a quoted attribute or element content, nothing is printed the same as the empty string.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag attribute='$nothing'>$nothing</tag>\")\n#-> <tag attribute=''></tag>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Nothing as an attribute value omits the attribute just like false. Nothing inside a tag is omitted as well.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag omit=$(nothing) $(nothing)/>\")\n#-> <tag/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A Pair inside a tag is treated as an attribute.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $(:att => :value)/>\")\n#-> <tag att='value'/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A symbol or string inside a tag are treated as empty attributes.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $(:att)/>\")\n#-> <tag att=''/>\n\n#? VERSION >= v\"1.6.0-DEV\"\n@print @htl(\"<tag $(\"att\")/>\")\n#-> <tag att=''/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A Dict inside a tag is treated as an attribute.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $(Dict(:att => :value))/>\")\n#-> <tag att='value'/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We do handle values within comments. Comments don't stop processing.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<!-- $(:hello) --><tag>$(:world)</tag>\")\n#-> <!-- hello --><tag>world</tag>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"When we normalize attribute names, we strip leading underscores.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $(:__att => :value)/>\")\n#-> <tag att='value'/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We don't expand into attributes things that don't look like attributes.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $(3)/>\")\n#-> ERROR: MethodError: no method matching inside_tag(::Int64)⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"One can add additional attributes following a bare name.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag bing $(:att)/>\")\n#-> <tag bing att=''/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Inside a tag, tuples can have many kinds of pairs.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"a1 = \"a1\"\n@print @htl(\"<tag $((a1,:a2,:a3=3,a4=4))/>\")\n#-> <tag a1='' a2='' a3='3' a4='4'/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The macro attempts to expand attributes inside a tag. To ensure the runtime dispatch also works, let's do a few things once indirect.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"hello = \"Hello\"\ndefer(x) = x\n\n@print @htl(\"<tag $(defer(:att => hello))/>\")\n#-> <tag att='Hello'/>\n\n@print @htl(\"<tag $(defer((att=hello,)))/>\")\n#-> <tag att='Hello'/>\n\n@print @htl(\"<tag $(:att => defer(hello))/>\")\n#-> <tag att='Hello'/>\n\n@print @htl(\"<tag $(defer(:att) => hello)/>\")\n#-> <tag att='Hello'/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Within a <script> tag, we want to ensure that numbers are properly converted.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"v = (-Inf, Inf, NaN, 6.02214e23)\n\n@print @htl(\"<script>var x = $v</script>\")\n#-> <script>var x = [-Infinity, Infinity, NaN, 6.02214e23]</script>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Besides dictionary objects, we support named tuples.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"v = (min=1, max=8)\n\n@print @htl(\"<script>var x = $v</script>\")\n#-> <script>var x = {\"min\": 1, \"max\": 8}</script>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Within a <script> tag, comment start (<!--) must also be escaped. Moreover, capital <Script> and permutations are included. We only scan the first character after the left-than character.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"v = \"<!-- <Script> <! 3<4 </ <s !>\"\n\n@print @htl(\"<script>var x = $v</script>\")\n#-> <script>var x = \"<\\!-- <\\Script> <\\! 3<4 <\\/ <\\s !>\"</script>","category":"page"},{"location":"design/#Lexer-Testing","page":"Design","title":"Lexer Testing","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"There are several HTML syntax errors that we can detect as part of our parser. For example, you shouldn't put comments within a script tag.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"<script><!-- comment --></script>\")\n#-> ERROR: LoadError: \"script escape or comment is not implemented\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Our lexer currently doesn't bother with processor instructions or doctype declarations. You could prepend these before your content.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"<?xml version='1.0'?>\")\n#=>\nERROR: LoadError: DomainError with <?xml ver…:\nunexpected question mark instead of tag name⋮\n=#\n\n@htl(\"<!DOCTYPE html>\")\n#-> ERROR: LoadError: \"DOCTYPE not supported\"⋮\n\n@htl(\"<![CDATA[No <b>CDATA</b> either.]]>\")\n#-> ERROR: LoadError: \"CDATA not supported\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"It's a lexing error to have an attribute lacking a name.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag =value/>\")\n#=>\nERROR: LoadError: DomainError with  =value/>:\nunexpected equals sign before attribute name⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"It's a lexing error to have an attribute lacking a value.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag att=>\")\n#=>\nERROR: LoadError: DomainError with =>:\nmissing attribute value⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Tags can be ended using SGML ending.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag></>\")\n#-> <tag></>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We add an extra space to ensure adjacent values parse properly.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $((:one))two=''/>\")\n#-> <tag one='' two=''/>\n\n@print @htl(\"<tag $((:one))$((:two))/>\")\n#-> <tag one='' two=''/>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Attribute names and values can be spaced out.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag one two = value />\")\n#-> <tag one two = value />","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Invalid attribute names are reported.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag at<ribute='val'/>\")\n#=>\nERROR: LoadError: DomainError with t<ribute=…\nunexpected character in attribute name⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Rawtext has a few interesting lexical cases.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"\"\"<style> </s </> </style>\"\"\")\n#-> <style> </s </> </style>\n\n@print @htl(\"<style> </s </style/\")\n#=>\nERROR: LoadError: DomainError with e/:\nunexpected solidus in tag⋮\n=#\n\n@print @htl(\"<style></style <\")\n#=>\nERROR: LoadError: DomainError with  <:\nunexpected character in attribute name⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Comments can contain interpolated values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"content = \"<!-- a&b -->\"\n\n@print @htl(\"<!-- $content -->\")\n#-> <!-- &lt;!-- a&amp;b --> -->","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Empty comments are permitted.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<!---->\")\n#-> <!---->","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Comments need to be well formed.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"<!-> \")\n#=>\nERROR: LoadError: DomainError with !-> :\nincorrectly opened comment⋮\n=#\n\n@htl(\"<!--> \")\n#=>\nERROR: LoadError: DomainError with -> :\nabrupt closing of empty comment⋮\n=#\n\n@htl(\"<!---> \")\n#=>\nERROR: LoadError: DomainError with -> :\nabrupt closing of empty comment⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Comments cannot contain a nested comment.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<!-- <!-- nested --> -->\")\n#=>\nERROR: LoadError: DomainError with - nested …:\nnested comment⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Comments can contain content that is similar to a comment block, but the recognition of these valid states is rather involved.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<!-- <!-->\")\n#-> <!-- <!-->\n\n@print @htl(\"<!--<x-->\")\n#-> <!--<x-->\n\n@print @htl(\"<!--<!x!>-->\")\n#-> <!--<!x!>-->\n\n@print @htl(\"<!--<!-x-->\")\n#-> <!--<!-x-->\n\n@print @htl(\"<!---x-->\")\n#-> <!---x-->\n\n@print @htl(\"<!--<<x-->\")\n#-> <!--<<x-->\n\n@print @htl(\"<!-- - --! --- --!- -->\")\n#-> <!-- - --! --- --!- -->","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Not so sure about this lexical production... perhaps it's a transcription error from the specification?","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<!----!>\")\n#=>\nERROR: LoadError: DomainError with !>:\nnested comment⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Even though actual content may be permitted in these odd spots, we don't generally permit interpolation.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<!--<$(:x)\")\n#=>\nERROR: LoadError: \"unexpected binding STATE_COMMENT_LESS_THAN_SIGN\"⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Of course, we could have pure content lacking interpolation, this also goes though the lexer.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<div>Hello<b>World</b>!</div>\")\n#-> <div>Hello<b>World</b>!</div>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"However, this macro requires a string literal.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"f() = \"<div>Hello<b>World</b>!</div>\"\n\n@print @htl(f())\n#=>\nERROR: LoadError: DomainError with f():\na string literal is required⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"That's it.","category":"page"},{"location":"primitives/#Utility-Classes","page":"Primitives","title":"Utility Classes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This is a regression test for components upon which HTL is constructed, the design centers around EscapeProxy which escapes content printed to it. There are several wrappers which drive special proxy handling.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"using HypertextLiteral: EscapeProxy, Bypass, Reprint, Render","category":"page"},{"location":"primitives/#EscapeProxy","page":"Primitives","title":"EscapeProxy","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This utility class acts wraps an IO stream to provide HTML escaping.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"io = IOBuffer()\nep = EscapeProxy(io)\n\nmacro echo(expr)\n    :($expr; print(String(take!(io))))\nend","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"The result of this proxy is that regular content printed to it is passed along to the wrapped IO, after escaping the ampersand (&), less-than (<), single-quote ('), and double-quote (\").","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"@echo print(ep, \"(&'<\\\")\")\n#-> (&amp;&apos;&lt;&quot;)","category":"page"},{"location":"primitives/#Bypass","page":"Primitives","title":"Bypass","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This wrapper simply prints its content.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"print(Bypass(\"<tagged/>\"))\n#-> <tagged/>","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Printed content wrapped with Bypass is not subject to escaping.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"@echo print(ep, Bypass(\"<span>\"), \"<A&B>\", Bypass(\"</span>\"))\n#-> <span>&lt;A&amp;B></span>","category":"page"},{"location":"primitives/#Reprint","page":"Primitives","title":"Reprint","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This wrapper holds a closure that prints to an io.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"print(Reprint(io::IO -> print(io, \"Hello World\")))\n#-> Hello World","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Reprinted content is still subject to escaping.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"@echo print(ep, Reprint(io -> print(io, \"(&'<\\\")\")))\n#-> (&amp;&apos;&lt;&quot;)","category":"page"},{"location":"primitives/#Render","page":"Primitives","title":"Render","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This wrapper prints text/html display of an object.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"struct Custom\n    content\nend\n\nBase.show(io::IO, m::MIME\"text/html\", c::Custom) =\n   print(io, c.content)\n\nprint(Render(Custom(\"<tag/>\")))\n#-> <tag/>","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"The printed content is not subject to escaping.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"@echo print(ep, Render(Custom(\"<tag/>\")))\n#-> <tag/>","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"It's an error if the wrapped object isn't showable to \"text/html\".","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"print(Render(\"This is an error!\"))\n#-> ERROR: MethodError: … show(… ::MIME{Symbol(\"text/html\")}⋮","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [HypertextLiteral]\nPrivate = true","category":"page"},{"location":"reference/#HypertextLiteral.HypertextLiteral","page":"Reference","title":"HypertextLiteral.HypertextLiteral","text":"HypertextLiteral\n\nThis library provides a @htl macro which implements interopolation that is aware of hypertext escape context.\n\n\n\n\n\n","category":"module"},{"location":"reference/#HypertextLiteral.CSS","page":"Reference","title":"HypertextLiteral.CSS","text":"CSS(js) - shows `js` as `\"text/css\"`\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.EscapeProxy","page":"Reference","title":"HypertextLiteral.EscapeProxy","text":"EscapeProxy(io) - wrap an `io` to perform HTML escaping\n\nThis is a transparent proxy that performs HTML escaping so that objects that are printed are properly converted into valid HTML values. As a special case, objects wrapped with Bypass are not escaped, and bypass the proxy.\n\nExamples\n\njulia> ep = EscapeProxy(stdout);\njulia> print(ep, \"A&B\")\nA&amp;B\njulia> print(ep, Bypass(\"<tag/>\"))\n<tag/>\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.JavaScript","page":"Reference","title":"HypertextLiteral.JavaScript","text":"JavaScript(js) - shows `js` as `\"text/javascript\"`\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Render","page":"Reference","title":"HypertextLiteral.Render","text":"Render(data) - printed object shows its text/html\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Reprint","page":"Reference","title":"HypertextLiteral.Reprint","text":"Reprint(fn) - apply the lambda function when printed\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Result","page":"Reference","title":"HypertextLiteral.Result","text":"Result(expr, unwrap)\n\nAddress display modalities by showing the macro expression that generated the results when shown on the REPL. However, when used with print() show the results. This object is also showable to any IO stream via \"text/html\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Script","page":"Reference","title":"HypertextLiteral.Script","text":"Script(data)\n\nThis object prints data unescaped within a <script> tag, wrapped in a ScriptProxy that guards against invalid script content.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.ScriptAttributeValue","page":"Reference","title":"HypertextLiteral.ScriptAttributeValue","text":"ScriptAttributeValue(data)\n\nThis object renders Javascript data escaped within an attribute.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.ScriptProxy","page":"Reference","title":"HypertextLiteral.ScriptProxy","text":"ScriptProxy(io)\n\nThis is a transparent proxy that ensures neither <!-- nor </script> occur in the output stream.\n\nExamples\n\njulia> gp = ScriptProxy(stdout);\njulia> print(gp, \"valid\");\nvalid\njulia> print(gp, \"</script>\")\n</scriptERROR: \"Content within a script tag must not contain `</script>`\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Style","page":"Reference","title":"HypertextLiteral.Style","text":"Style(data)\n\nThis object prints data unescaped within a <script> tag, wrapped in a StyleProxy that guards against invalid script content.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.StyleProxy","page":"Reference","title":"HypertextLiteral.StyleProxy","text":"StyleProxy(io)\n\nThis is a transparent proxy that ensures neither <!-- nor </style> occur in the output stream.\n\nExamples\n\njulia> gp = StyleProxy(stdout);\njulia> print(gp, \"valid\");\nvalid\njulia> print(gp, \"</style>\")\n</styleERROR: \"Content within a style tag must not contain `</style>`\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.attribute_value-Tuple{String}","page":"Reference","title":"HypertextLiteral.attribute_value","text":"attribute_value(x)\n\nThis method may be implemented to specify a printed representation suitable for use within a quoted attribute value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.content-Tuple{Any}","page":"Reference","title":"HypertextLiteral.content","text":"content(x)\n\nThis method may be implemented to specify a printed representation suitable for text/html output. AbstractString, Symbol and Number (including Bool) types are printed, with proper escaping.\n\nA default implementation first looks to see if typeof(x) has implemented a way to show themselves as text/html, if so, this is used. Otherwise, the result is printed within a <span> tag, using a class that includes the module and type name. Hence, missing is serialized as: <span class=\"Base-Missing\">missing</span>.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.interpolate-Tuple{Any, Any}","page":"Reference","title":"HypertextLiteral.interpolate","text":"interpolate(args, this)::Expr\n\nTake an interweaved set of Julia expressions and strings, tokenize the strings according to the HTML specification [1], wrapping the expressions with wrappers based upon the escaping context, and returning an expression that combines the result with an Result wrapper.\n\nFor these purposes, a Symbol is treated as an expression to be resolved; while a String is treated as a literal string that won't be escaped. Critically, interpolated strings to be escaped are represented as an Expr with head of :string.\n\nThere are tags, \"script\" and \"style\" which are rawtext, in these cases there is no escaping, and instead raise an exception if the appropriate ending tag is in substituted content.\n\n[1] https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.normalize_attribute_name-Tuple{Symbol}","page":"Reference","title":"HypertextLiteral.normalize_attribute_name","text":"normalize_attribute_name(name)\n\nFor String names, this simply verifies that they pass the attribute name production, but are otherwise untouched.\n\nFor Symbol names, this converts snake_case Symbol objects to their kebab-case equivalent. So that keywords, such as for could be used, we strip leading underscores.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.print_script-Tuple{IO, Any}","page":"Reference","title":"HypertextLiteral.print_script","text":"print_script(io, value)\n\nShow value as \"text/javascript\" to the given io, this provides some baseline functionality for built-in data types.\n\n- `nothing` becomes `undefined`\n- `missing` becomes `null`\n- `Bool` values are printed as `true` or `false`\n- `AbstractString` and `Symbol` become a double-quoted string\n- `AbstractVector` and `Tuple` become an array\n- `Dict` and `NamedTuple` become a Javascript object, with\n   keys converted to string values\n- `AbstractFloat` and `Integer` are printed directly, where\n  `NaN` remains `NaN` but `Inf` is printed as `Infinity`\n\nThe fallback behavior of print_script is to show the object as \"text/javascript\". The Javascript wrapper will take any string and let it be printed in this way.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.print_script_lower-Tuple{IO, Any}","page":"Reference","title":"HypertextLiteral.print_script_lower","text":"print_script_lower(io, value)\n\nProvides a hook to override print_script for custom Javascript runtimes, such as Pluto.jl, to provide their own value marshalling.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.print_style_lower-Tuple{IO, Any}","page":"Reference","title":"HypertextLiteral.print_style_lower","text":"print_style_lower(io, value)\n\nProvides a hook to override print_value to provide custom CSS encoding.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.print_value-Tuple{IO, Any}","page":"Reference","title":"HypertextLiteral.print_value","text":"print_value(io, value)\n\nThis is the default translation of interpolated values within rawtext tags, such as <style> and attribute values.\n\nThe elements of a Tuple or AbstractArray object are printed, with a space between each item.\nThe Pair, NamedTuple, and Dict objects are treated as if they are CSS style elements, with a colon between key and value, each pair delimited by a semi-colon.\nThe Nothing object is treated as an empty string.\n\nOtherwise, this method simply uses the standard print representation for the given object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.rewrite_inside_tag-Tuple{Any}","page":"Reference","title":"HypertextLiteral.rewrite_inside_tag","text":"rewrite_inside_tag(expr)\n\nAttempt to speed up serialization of inside_tag by exploring the expression tree at macro expansion time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.script_attribute_value-Tuple{Any}","page":"Reference","title":"HypertextLiteral.script_attribute_value","text":"script_attribute_value(x)\n\nThis method may be implemented to specify a printed representation suitable for use within a quoted attribute value starting with on.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.@htl-Tuple{Any}","page":"Reference","title":"HypertextLiteral.@htl","text":"@htl string-expression\n\nCreate a Result object with string interpolation ($) that uses context-sensitive hypertext escaping. Before Julia 1.6, interpolated string literals, e.g. $(\"Strunk & White\"), are treated as errors since they cannot be reliably detected (see Julia issue #38501).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#HypertextLiteral.@htl_str-Tuple{String}","page":"Reference","title":"HypertextLiteral.@htl_str","text":"@htl_str -> Result\n\nCreate a Result object with string interpolation ($) that uses context-sensitive hypertext escaping. Unlike the @htl macro, this string literal does not include escaping feature [1]. To include $ within user content one must write &#36;. Observe that &quot; and any other HTML ampersand escape sequence can be used as appropriate.\n\nIn this syntax, interpolation is extended beyond regular Julia strings to handle three additional cases: tuples, named tuples (for attributes), and generators. See Julia #38734 for the feature request so that this could also work within the @htl macro syntax.\n\n[1] There are also a few edge cases, see @raw_str documentation and Julia #22926 for more detail.\n\n\n\n\n\n","category":"macro"},{"location":"#Introduction","page":"Usage","title":"Introduction","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"This package provides a Julia macro, @htl, that constructs an object which could be rendered to MIME\"text/html\" displays. This macro supports interpolation sensible to the needs of HTML generation.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"using HypertextLiteral","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"When printed directly to the console (via show), the output of this macro reproduces the expression that generated them.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"name = \"World\"\n\n@htl(\"<span>Hello $name</span>\")\n#-> @htl \"<span>Hello $(name)</span>\"","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"When displayed to \"text/html\" or printed, the evaluation is shown.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"name = \"World\"\n\ndisplay(\"text/html\", @htl(\"<span>Hello $name</span>\"))\n#-> <span>Hello World</span>\n\nprint(@htl(\"<span>Hello $name</span>\"))\n#-> <span>Hello World</span>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"We use NarrativeTest.jl to ensure our examples are correct. After each command is a comment with the expected output. To enhance readability, we'll also use the following macro.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"macro print(expr)\n    :(display(\"text/html\", $expr))\nend\n\n@print @htl(\"<span>Hello World</span>\")\n#-> <span>Hello World</span>","category":"page"},{"location":"#Content-Interpolation","page":"Usage","title":"Content Interpolation","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"Hypertext literal provides interpolation via $. Within content, the ampersand (&), less-than (<), single-quote (') and double-quote (\") are escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"book = \"Strunk & White\"\n\n@print @htl(\"<span>Today's Reading: $book</span>\")\n#-> <span>Today's Reading: Strunk &amp; White</span>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"To include $ in the output, use \\$ as one would in a regular Julia string. Other escape sequences, such as \\\" also work.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"They said, \\\"your total is \\$42.50\\\".\")\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Within tripled double-quotes, single double-quoted strings can go unescaped, however, we still need to escape the dollar sign ($).","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"\"\"They said, \"your total is \\$42.50\".\"\"\")\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Julia results can be interpolated using the $(expr) notation. Strings, numeric values (including Bool) and symbols are supported.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"2+2 = $(2+2)\")\n#-> 2+2 = 4\n\n@print @htl(\"<bool>$(false)</bool><sym>$(:sym)</sym>\")\n#-> <bool>false</bool><sym>sym</sym>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Objects created by these macros are not further escaped, permitting us to build reusable HTML templates.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"sq(x) = @htl(\"<span>$(x*x)</span>\")\n\n@print @htl(\"<div>3^2 is $(sq(3))</div>\")\n#-> <div>3^2 is <span>9</span></div>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Numbers (including boolean values), symbols, and string values are printed as is. Values of specific types, such as missing are wrapped in a <span> tag with a class attribute including the module.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"\"\"<div>$(missing)</div>\"\"\")\n#-> <div><span class=\"Base-Missing\">missing</span></div>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Content generated by these macros can be nested. Within element content, vectors and generators are automatically expanded, concatenating their values.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"books = [\"Who Gets What & Why\", \"Switch\", \"Governing The Commons\"]\n\n@print @htl(\"<ul>$([@htl(\"<li>$b\") for b in books])</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#\n\n@print @htl(\"<ul>$((@htl(\"<li>$b\") for b in books))</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"The map(container) do item; … ;end construct works and is performant.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<ul>$(map(books) do b @htl(\"<li>$b\") end)</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"#Attribute-Interpolation","page":"Usage","title":"Attribute Interpolation","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"Interpolation within single and double quoted attribute values are supported. Regardless of context, all four characters are escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"qval = \"\\\"&'\"\n\n@print @htl(\"\"\"<tag double=\"$qval\" single='$qval' />\"\"\")\n#-> <tag double=\"&quot;&amp;&apos;\" single='&quot;&amp;&apos;' />","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Unquoted or bare attributes are also supported. These are serialized using the single quoted style so that spaces and other characters do not need to be escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"arg = \"book='Strunk & White'\"\n\n@print @htl(\"<tag bare=$arg />\")\n#-> <tag bare='book=&apos;Strunk &amp; White&apos;' />","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Attributes may also be provided by any combination of dictionaries, named tuples, and pairs. Attribute names are normalized, where snake_case becomes kebab-case. We do not convert camelCase due to XML (MathML and SVG) attribute case sensitivity. Moreover, String attribute names are passed along as-is.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":" attributes = Dict(:data_style => :green, \"data_value\" => 42, )\n\n @print @htl(\"<div $attributes/>\")\n #-> <div data-style='green' data_value='42'/>\n\n @print @htl(\"<div $(:data_style=>:green) $(:dataValue=>42)/>\")\n #-> <div data-style='green' dataValue='42'/>\n\n @print @htl(\"<div $((:data_style=>:green, \"data_value\"=>42))/>\")\n #-> <div data-style='green' data_value='42'/>\n\n @print @htl(\"<div $((data_style=:green, dataValue=42))/>\")\n #-> <div data-style='green' dataValue='42'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"As you can see from this example, symbols and numbers (but not boolean values) are automatically printed within attributes. This interpolation works within quoted values as well.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"\"\"<tag numeric=\"$(0)\" symbol='$(:sym)'/>\"\"\")\n#-> <tag numeric=\"0\" symbol='sym'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Within bare attributes, boolean values provide special support for boolean HTML properties, such as \"disabled\". When a bare value false then the attribute is removed. When the value is true then the attribute is kept, with value being an empty string ('').","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<button checked=$(true) disabled=$(false)>\")\n#-> <button checked=''>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"In HTML, many attributes specify values with space-delimited tokens, such as the Cascading Style Sheet (CSS) \"class\" attribute. To support these attributes, arrays and tuples produce space delimited output.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<div class=$([:one, :two])/>\")\n#-> <div class='one two'/>\n\n@print @htl(\"<div class=$((:one, :two))/>\")\n#-> <div class='one two'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"To support nested key/value structures, such as the CSS \"style\" attribute, we have specialized expansion of dictionary like objects. For each pair, keys are separated from their value with a colon :, moreover, pairs are delimited by the semi-colon (;). Like attributes, snake_case is converted to kebab-case.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"header_styles = Dict(:font_size => \"25px\", \"padding-left\" => \"2em\")\n\n@print @htl(\"<div style=$header_styles/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@print @htl(\"<div style=$((:font_size=>\"25px\",\"padding-left\"=>\"2em\"))/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@print @htl(\"<div style=$((font_size=\"25px\", padding_left=\"2em\"))/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"These expansions work within quoted attributes.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"extra = Dict(:padding_left => \"2em\")\n\n@print @htl(\"<div style='font-size: 25px; $extra'/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@print @htl(\"<div style='font-size: 25px; $(:padding_left => \"2em\")'/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>","category":"page"},{"location":"#Script-Interpolation","page":"Usage","title":"Script Interpolation","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"Within a <script> tag, Julia values are serialized to their equivalent Javascript. String literal values are rendered as double-quoted values.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"v = \"\"\"I see \"M&M's\"!\"\"\";\n\n@print @htl(\"<script>var x = $v</script>\")\n#-> <script>var x = \"I see \\\"M&M's\\\"!\"</script>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Julia tuples and vectors are serialized as Javascript array. Integers, boolean, and floating point values are handled. As special cases, nothing is represented using undefined and missing using null.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"v = Any[true, 1, 1.0, nothing, missing]\n\n@print @htl(\"<script>var x = $v</script>\")\n#-> <script>var x = [true, 1, 1.0, undefined, null]</script>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Julia named tuples and dictionaries are serialized as a Javascript object. Symbols are converted to string values.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"v = Dict(:min=>1, :max=>8)\n\n@print @htl(\"<script>var x = $v</script>\")\n#-> <script>var x = {\"max\": 8, \"min\": 1}</script>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Within a <script> tag, comment start, script open, and close tags are properly escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"v = \"<script>nested</script>\"\n\n@print @htl(\"<script>var x = $v</script>\")\n#-> <script>var x = \"<\\script>nested<\\/script>\"</script>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Sometimes you already have content that is valid Javascript. This can be printed directly, without escaping using a wrapper similar to HTML:","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"using HypertextLiteral: JavaScript\n\nexpr = \"\"\"console.log(\"Hello World\")\"\"\"\n\n@print @htl(\"<script>$(JavaScript(expr))</script>\")\n#-> <script>console.log(\"Hello World\")</script>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"The JavaScript wrapper indicates the content should be printed within a \"text/javascript\" context. Even so, it does help catch content which is not propertly escaped for use within a <script> tag.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"expr = \"\"\"<script>console.log(\"Hello World\")</script>\"\"\"\n\n@print @htl(\"<script>$(JavaScript(expr))</script>\")\n#-> …ERROR: \"Content within a script tag must not contain `</script>`\"⋮","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"…","category":"page"},{"location":"notation/#The-htl-notation-(non-standard-string-literal-macro)","page":"Notation","title":"The htl notation (non-standard string literal macro)","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"This package additionally provides the @htl_str notation which has the advantage of being more succinct than @htl macro.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"using HypertextLiteral: @htl, @htl_str\n\nmacro print(expr) :(display(\"text/html\", $expr)); end","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"name = \"World\"\n\nhtl\"<span>Hello $name</span>\"\n#-> htl\"<span>Hello $name</span>\"","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Strings prefixed by htl are processed by @htl_str.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"name = \"World\"\n\n@print htl\"<span>Hello $name</span>\"\n#-> <span>Hello World</span>\n\n@print @htl_str(\"<span>Hello \\$name</span>\")\n#-> <span>Hello World</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Other than a handful of exceptions, htl\"<tag/>\" and @htl(\"<tag/>\") are otherwise identical in behavior.","category":"page"},{"location":"notation/#Dynamic-Templates","page":"Notation","title":"Dynamic Templates","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"The @htl_str macro can be used to dynamically construct templates in combination with eval. Suppose you have a schema that is provided dynamically. Let's make a test database with exactly one row.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"T = NamedTuple{(:idx, Symbol(\"A <Value>\")), Tuple{Int64, String}};\n\ndatabase = [T((1, \"A&B\"))];\n\ndisplay(database)\n#=>\n1-element Vector{NamedTuple{(:idx, Symbol(\"A <Value>\")), …}:\n (idx = 1, A <Value> = \"A&B\")\n=#","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"We could construct a table header from this schema.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"fields = T.parameters[1]\n#-> (:idx, Symbol(\"A <Value>\"))\n\nhead = @htl(\"<tr>$([@htl(\"<th>$x\") for x in fields])\")\n\n@print head\n#-> <tr><th>idx<th>A &lt;Value>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Then, we need to compute a template for each row.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"row_template = \"<tr>$(join([\"<td>\\$(row[$(repr(x))])\" for x in fields]))\"\n\nprint(row_template)\n#-> <tr><td>$(row[:idx])<td>$(row[Symbol(\"A <Value>\")])","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Using eval with @htl_str we could construct our template function.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"eval(:(tablerow(row) = @htl_str $row_template))\n\n@print tablerow(database[1])\n#-> <tr><td>1<td>A&amp;B","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"A template for the entire table could be constructed.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"table_template = \"<table>$head\\$([tablerow(row) for row in data])</table>\"\n\nprint(table_template)\n#-> <table><tr><th>idx…$([tablerow(row) for row in data])</table>\n\neval(:(print_table(data) = @htl_str $table_template))","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Then, finally, this could be used.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print print_table(database)\n#-> <table><tr><th>idx<th>A &lt;Value><tr><td>1<td>A&amp;B</table>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Of course, one should be careful about using eval to ensure that the template itself is well sanitized.","category":"page"},{"location":"notation/#Notable-Differences","page":"Notation","title":"Notable Differences","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"Unlike @htl, htl uses @raw_str escaping rules. In particular, so long as a double-quote character does not come before a slash, the slash itself need not be escaped.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"<span>\\some\\path</span>\"\n#-> <span>\\some\\path</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"To represent the dollar-sign, use use HTML character entity #&36;.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"amount = 42\n\n@print htl\"<span>They paid &#36;$amount</span>\"\n#-> <span>They paid &#36;42</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Unlike macros, this syntax does not nest.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"Hello $(htl\"World\")\"\n#-> ERROR: syntax: cannot juxtapose string literal","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Triple double-quoted syntax can be used as a work around.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"\"\"Hello $(htl\"World\")\"\"\"\n#-> Hello World","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"However, this trick works only one level deep. Hence, there are some significant downsides to using this format, which are explored in detail at Julia #38948.","category":"page"},{"location":"notation/#Marginal-Benefits","page":"Notation","title":"Marginal Benefits","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"Since the implementers of the notation have some control over the parsing, there are some benefits. First, we can reliably detect string literals (Julia #38501) before v1.6. This is fixed in Julia 1.6+","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"\"\"<span>$(\"A&B\")</span>\"\"\"\n#-> <span>A&amp;B</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Second, there is one less round of parenthesis needed for tuples, named tuples and generators (Julia #38734). This is especially useful when building attributes.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"name = \"Hello\"\n\n@print htl\"<tag $(user=name,)/>\"\n#-> <tag user='Hello'/>\n\n@print htl\"<span>$(n for n in 1:3)</span>\"\n#-> <span>123</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Beyond these differences, this could just be a matter of preference; or which form of syntax highlighting works best.","category":"page"},{"location":"notation/#Regression-Tests-and-Notes","page":"Notation","title":"Regression Tests & Notes","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"Due to @raw_str escaping, string literal forms are a bit quirky. Use the triple double-quoted form if your content has a double quote. Avoid slashes preceding a double quote, instead use the &#47; HTML entity.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"\\\"\\t\\\\\"\n#-> \"\\t\\\n\n@print htl\"(\\\\\\\")\"\n#-> (\\\")","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Even though we could permit interpretation of arrays notation, we stick with keeping this an error for consistency with the macro form.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"htl\"$[1,2,3]\"\n#=>\nERROR: LoadError: DomainError with [1, 2, 3]:\ninterpolations must be symbols or parenthesized⋮\n=#","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Let's also not permit top-level assignments.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"htl\"$(k=value)\"\n#=>\nERROR: LoadError: DomainError with k = value:\nassignments are not permitted in an interpolation⋮\n=#","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [HypertextLiteral]\nPrivate = true","category":"page"},{"location":"reference/#HypertextLiteral.HypertextLiteral","page":"Reference","title":"HypertextLiteral.HypertextLiteral","text":"HypertextLiteral\n\nThis library provides for a @htl() macro and a htl string literal, both implementing interpolation that is aware of hypertext escape context. The @htl macro has the advantage of using Julia's native string parsing, so that it can handle arbitrarily deep nesting. However, it is a more verbose than the htl string literal and doesn't permit interpolated string literals. Conversely, the htl string literal, @htl_str, uses custom parsing letting it handle string literal escaping, however, it can only be used two levels deep (using three quotes for the outer nesting, and a single double quote for the inner).\n\n\n\n\n\n","category":"module"},{"location":"reference/#HypertextLiteral.HTL","page":"Reference","title":"HypertextLiteral.HTL","text":"HTL(s): Create an array of objects that render as html.\n\nHTL(\"<div>foo</div>\")\n\nThis is similar HTML{Vector} with a few exceptions. First, the contents of the vector are concatenated. Second, direct rendering is limited to AbstractString, others are delegated to show. Third, the splat constructor converts arguments to the HTL vector.\n\nFinally, regular display of the value to the terminal renders the objects and produces the equivalent string representation (unwise?).\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.HTLAttribute","page":"Reference","title":"HypertextLiteral.HTLAttribute","text":"HTLAttribute{name}\n\nThis parameterized type to represent HTML attributes so that we could dispatch serialization of custom attributes and data types. This is modeled upon the MIME data type. Values written in this way must be escaped for use in an unquoted string, htl_escape can do this.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.InterpolatedValue","page":"Reference","title":"HypertextLiteral.InterpolatedValue","text":"Interpolated Value\n\nThis abstract type represents a value that must be escaped. The various subclasses provide the context for the escaping. They include:\n\nElementData            Values expanded as element content, including                          text nodes and/or subordinate HTML fragments   ElementAttributes      Values to be expanded as attribute/value pairs   AttributePair          Unquoted name/value pair for attributes; handles                          special cases of boolean attributes   AttributeDoubleQuoted  Value serialized within double quoted attribute   AttributeSingleQuoted  Value serialized within single quoted attribute\n\nThe string interpolation is here is conservative. To provide express data type conversions for ElementData, override show \"text/html\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.css_value-Tuple{Symbol}","page":"Reference","title":"HypertextLiteral.css_value","text":"css_value(val)\n\nConvert a native Julia object into a string suitable for use as a CSS value. This is useful for adding support for cssunits or other tools that build CSS fragments.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.htl_escape-Tuple{AbstractString}","page":"Reference","title":"HypertextLiteral.htl_escape","text":"htl_escape(s)\n\nPerform extensive escaping needed for a string to be used as an unquoted attribute. This can also be used for quoted values or within element content (although it's overkill).\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.htl_stringify_value-Tuple{Any}","page":"Reference","title":"HypertextLiteral.htl_stringify_value","text":"htl_stringify_value(value)::String\n\nConvert a value` to a string suitable to inclusion as a quoted attribute. Escaping (according to quoting style) is done after this step. By default, strings are treated as-is; symbols and numbers (but not booleans) are automatically converted to strings.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.interpolate-Tuple{Any}","page":"Reference","title":"HypertextLiteral.interpolate","text":"interpolate(args):Expr\n\nTake an interweaved set of Julia expressions and strings, tokenize the strings according to the HTML specification [1], wrapping the expressions with wrappers based upon the escaping context, and returning an expression that combines the result with an HTL wrapper.\n\nFor these purposes, a Symbol is treated as an expression to be resolved; while a String is treated as a literal string that won't be escaped. Critically, interpolated strings to be escaped are represented as an Expr with head of :string.\n\nThere are tags, \"script\" and \"style\" which are rawtext, in these cases there is no escaping, and instead raise an exception if the appropriate ending tag is in substituted content.\n\n[1] https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.@htl-Tuple{Any}","page":"Reference","title":"HypertextLiteral.@htl","text":"@htl string-expression\n\nCreate a HTL object with string interpolation ($) that uses context-sensitive hypertext escaping. Before Julia 1.6, interpolated string literals, e.g. $(\"Strunk & White\"), are treated as errors since they cannot be reliably detected (see Julia issue #38501).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#HypertextLiteral.@htl_str-Tuple{String}","page":"Reference","title":"HypertextLiteral.@htl_str","text":"@htl_str -> HTL\n\nCreate a HTL object with string interpolation ($) that uses context-sensitive hypertext escaping. Escape sequences should work identically to Julia strings, except in cases where a slash immediately precedes the double quote (see @raw_str and Julia issue #22926).\n\n\n\n\n\n","category":"macro"},{"location":"#HypertextLiteral.jl","page":"Tutorial","title":"HypertextLiteral.jl","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"This package provides a Julia string literal, htl, and macro @htl that return an object that can be rendered to MIME\"text/html\" displays. These macros support context-sensitive interpolation sensible to the needs of HTML generation.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"using HypertextLiteral","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"We use NarrativeTest.jl to ensure our examples are correct. After each command is a comment with the expected output. This tool ensures the README can be validated by running ./test/runtests.jl. To enhance readability, we define the following macro.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"macro print(expr)\n    :(display(\"text/html\", $expr))\nend","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"HypertextLiteral provides an htl string literal and equivalent @htl macro that implement contextual escaping and expression interpolation, producing HTL objects that render to \"text/html\".","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"<span>Hello World</span>\"\n#-> HTL(\"<span>Hello World</span>\")\n\n@htl(\"<span>Hello World</span>\")\n#-> HTL(\"<span>Hello World</span>\")","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"An HTL object can be rendered to \"text/html\" with display(). The expected output is shown in the comment below the command.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"display(\"text/html\", htl\"<span>Hello World</span>\")\n#-> <span>Hello World</span>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we use the @print macro defined above to increase readability without having to type this display function.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"<span>Hello World</span>\"\n#-> <span>Hello World</span>","category":"page"},{"location":"#Content-Interpolation","page":"Tutorial","title":"Content Interpolation","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Hypertext literal provides interpolation via $. Within element content, both the ampersand (&) and less-than (<) are escaped.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"book = \"Strunk & White\"\n\n@print htl\"<span>Today's Reading: $book</span>\"\n#-> <span>Today's Reading: Strunk &#38; White</span>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"To include a literal $ in the output, use \\$ as one would in a regular Julia string. Other escape sequences, such as \\\" also work.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"They said, \\\"your total is \\$42.50\\\".\"\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"String literals can also be triple-quoted, allowing them to span multiple lines. Within triple quotes, single quoted strings can go unescaped, however, we still need to escape the dollar sign ($).","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"\"\"They said, \"your total is \\$42.50\".\"\"\"\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Within any of these forms, Julia results can be interpolated using the $(expr) notation. Numeric values (including Bool) and symbols are automatically converted to their string representation.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"2+2 = $(2+2)\"\n#-> 2+2 = 4\n\n@print htl\"<bool>$(false)</bool><sym>$(:sym)</sym>\"\n#-> <bool>false</bool><sym>sym</sym>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Functions returning string values will be escaped.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"input() = \"<script>alert('a&b!')\"\n\n@print htl\"$(input())\"\n#-> &#60;script>alert('a&#38;b!')","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Functions returning HTL objects are not further escaped. This permits us to build reusable HTML templates.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"sq(x) = htl\"<span>$(x*x)</span>\"\n\n@print htl\"<div>3^2 is $(sq(3))</div>\"\n#-> <div>3^2 is <span>9</span></div>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Within a triple-quoted htl string, a single-quoted htl string can be included. This technique only works for one level of nesting.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"books = [\"Who Gets What & Why\", \"Switch\", \"Governing The Commons\"]\n\n@print htl\"\"\"<ul>$([htl\"<li>$b\" for b in books])</ul>\"\"\"\n#=>\n<ul><li>Who Gets What &#38; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"The equivalent macro syntax supports arbitrary levels of nesting, although we only show one level of nesting here.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"books = [\"Who Gets What & Why\", \"Switch\", \"Governing The Commons\"]\n\n@print @htl(\"<ul>$(map(books) do b @htl(\"<li>$b\") end)</ul>\")\n#=>\n<ul><li>Who Gets What &#38; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"#Attribute-Interpolation","page":"Tutorial","title":"Attribute Interpolation","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Escaping of Julia values depends upon the context: within a double quoted attribute value, the double quote is escaped; single quoted attributes are likewise escaped.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"qval = \"\\\"h&b'\"\n\n@print htl\"\"\"<tag double=\"$qval\" single='$qval' />\"\"\"\n#-> <tag double=\"&#34;h&#38;b'\" single='\"h&#38;b&#39;' />","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Unquoted attributes are also supported. Here the escaping is extensive.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"arg = \"book=Strunk & White\"\n\n@print htl\"<tag bare=$arg />\"\n#-> <tag bare=book&#61;Strunk&#32;&#38;&#32;White />","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Attributes may also be provided by Dict or Pair. Attribute names provided as a String are passed though as-is, while Symbol values go though camelCase case conversion. For those that prefer unix style names, underscores to dash conversion is also provided.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":" attributes = Dict(:dataValue => 42, \"data-style\" => :green )\n\n @print @htl(\"<div $attributes/>\")\n #-> <div data-value=42 data-style=green/>\n\n @print @htl(\"<div $(:data_value=>42) $(\"data-style\"=>:green)/>\")\n #-> <div data-value=42 data-style=green/>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Within string literals (but not @htl macro), a compact syntax inspired by named tuples is also supported.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":" @print htl\"<div $(data_value=42, dataStyle=:green)/>\"\n #-> <div data-value=42 data-style=green/>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"As you can see from this example, symbols and numbers (but not boolean values) are automatically converted within attributes. This works for quoted values as well.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"\"\"<tag numeric=\"$(0)\" symbol='$(:sym)'/>\"\"\"\n#-> <tag numeric=\"0\" symbol='sym'/>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Within bare attributes, boolean values provide special support for boolean HTML properties, such as \"disabled\". When a bare value false then the attribute is removed. When the value is true then the attribute is kept, with value being an empty string ('').","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"<button checked=$(true) disabled=$(false)>\"\n#-> <button checked=''>","category":"page"},{"location":"#Cascading-Style-Sheets","page":"Tutorial","title":"Cascading Style Sheets","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"There is special support for the unquoted \"style\" attribute. In this case, Pair and Dict values are expanded as style attributes separated by the semi-colon (;). Style names that are Symbol values go though camelCase conversion to camel-case, while String values are passed along as-is.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"header_styles = Dict(:fontSize => \"25px\", \"padding-left\" => \"2em\")\n\n@print htl\"<div style=$header_styles/>\"\n#-> <div style=font-size:&#32;25px;padding-left:&#32;2em;/>\n\n@print htl\"\"\"<div style=$(:fontSize=>\"25px\",\"padding-left\"=>\"2em\")/>\"\"\"\n#-> <div style=font-size:&#32;25px;padding-left:&#32;2em;/>\n\n@print htl\"\"\"<div style=$(fontSize=\"25px\",paddingLeft=\"2em\")/>\"\"\"\n#-> <div style=font-size:&#32;25px;padding-left:&#32;2em;/>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Only symbols, numbers, and strings have a specified serialization as css style values. Therefore, use of components from other libraries will cause an exception.  However, this can be fixed by registering a conversion using css_value().","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"using Hyperscript\n\nHypertextLiteral.css_value(x::Hyperscript.Unit) = string(x)","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Then, the syntax for CSS can be even more compact.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"<div style=$(fontSize=25px,paddingLeft=2em)/>\"\n#-> <div style=font-size:&#32;25px;padding-left:&#32;2em;/>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"For the unquoted \"class\" attribute, a Vector provides a space between each of the elements.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print @htl(\"<div class=$([:one, :two])/>\")\n#-> <div class=one&#32;two/>\n\n@print htl\"<div class=$(:one, :two)/>\"\n#-> <div class=one&#32;two/>","category":"page"},{"location":"#Design-Discussion-and-Custom-Extensions","page":"Tutorial","title":"Design Discussion and Custom Extensions","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"So that we could distinguish between regular strings and strings that are meant to be hypertext, we define the type HTL which is an array containing String values, which are assumed to be valid hypertext, and objects that are Multimedia.showable as \"text/html\".","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"<span>Hello World!</span>\"\n#-> HTL(\"<span>Hello World!</span>\")\n\ndisplay(\"text/html\", HTL(\"<span>Hello World!</span>\"))\n#-> <span>Hello World!</span>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"We considered using Docs.HTML for this purpose, but it has the wrong semantics. The HTML type it is intended to promote the \"text/plain\" representation of any object to something showable as \"text/html\".","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"display(\"text/html\", HTML([\"<span>\", HTML(\"content\"), \"</span>\"]))\n#-> Any[\"<span>\", HTML{String}(\"content\"), \"</span>\"]","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"By contrast, HTL concatenates vectors and unwraps objects showable as \"text/html\". Like HTML, String values are assumed to be properly escaped (the htl string literal and macro do this escaping).","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"display(\"text/html\", HTL([\"<span>\", HTL(\"content\"), \"</span>\"]))\n#-> <span>content</span>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"If one attempts to reference a user defined type, it will be an error.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"struct Custom data::String end\n\nHTL(Custom(\"a&b\"))\n#=>\nERROR: DomainError with …Custom(\"a&b\"):\nElements must be strings or objects showable as \"text/html\".\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"This can be addressed by implementing the \"text/html\" mimetype inBase.showfor the custom type in question. In this case, be sure to escape ampersand (&) and less-than (<`).","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":" struct Custom data::String end\n\n function Base.show(io::IO, mime::MIME\"text/html\", c::Custom)\n     value = replace(replace(c.data, \"&\" => \"&amp;\"), \"<\" => \"&lt;\")\n     print(io, \"<custom>$(value)</custom>\")\n end\n\n @print @htl(\"<span>$(Custom(\"a&b\"))</span>\")\n #-> <span><custom>a&amp;b</custom></span>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"In this conservative approach, unknown types are not simply stringified when they are used in element content or as an array value. Instead, they produce an error.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"struct Custom data::String end\n\n@htl(\"<tag data-custom=$(Custom(\"a&b\"))/>\")\n#=>\nERROR: DomainError with …Custom(\"a&b\"):\n  Unable to convert …Custom for use as an attribute value;\n  convert to a string or, for a specific attribute, implement a\n  `Base.show` method using `HTLAttribute` (and `htl_escape`)\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"We could tell HTL how to serialize our Custom values to the data-custom attribute by implementing Base.show using HTLAttribute, as show below.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"import HypertextLiteral: HTLAttribute, htl_escape\n\nstruct Custom data::String end\n\nBase.show(io::IO, at::HTLAttribute{Symbol(\"data-custom\")}, value::Custom) =\n    print(io, htl_escape(value.data))\n\n@print @htl(\"<tag data-custom=$(Custom(\"a&b\"))/>\")\n#-> <tag data-custom=a&#38;b/>\n\n@print @htl(\"<tag $(:dataCustom => Custom(\"a&b\"))/>\")\n#-> <tag data-custom=a&#38;b/>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"So that the scope of objects serialized in this manner is clear, we don't permit adjacent unquoted values.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"<tag bare=$(true)$(:invalid)\"\n#=>\nERROR: LoadError: DomainError with bare=true:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"To have a convenient notation, our string macro syntax interpolate tuples and generated expressions as concatinated output. This is currently not supported by @htl macro (see Julia ticket #38734).","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"a = \"A\"\nb = \"B\"\n\n@print htl\"$(a,b)\"\n#-> AB\n\n@print htl\"$(x for x in (a,b))</tag>\"\n#-> AB\n\n@htl(\"$(x for x in (a,b))\")\n#-> ERROR: syntax: invalid interpolation syntax","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"While assigment operator is permitted in Julia string interpolation, we exclude it in both string literal and macro forms so to guard against accidentially forgetting the trailing comma for a 1-tuple.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"\"\"<div $(dataValue=42,)/>\"\"\"\n#-> <div data-value=42/>\n\nhtl\"\"\"<div $(dataValue=42)/>\"\"\"\n#=>\nERROR: LoadError: DomainError with dataValue = 42:\nassignments are not permitted in an interpolation⋮\n=#\n\n@htl(\"<div $(dataValue=42)/>\")\n#=>\nERROR: LoadError: DomainError with dataValue = 42:\nassignments are not permitted in an interpolation⋮\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Even though booleans are considered numeric in Julia, we treat them as an error to guard against quoted use in boolean HTML attributes.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"<button checked='$(true)'\"\n#=>\nERROR: DomainError with true:\n  Unable to convert Bool for use as an attribute value;\n  convert to a string or, for a specific attribute, implement a\n  `Base.show` method using `HTLAttribute` (and `htl_escape`)\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"To increase usability on the command line, the default representation of an HTL object is its equivalent pre-rendered string. Even so, the HTL object retains component parts so they could be inspected.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@htl(\"<span>$(Custom(\"a&b\"))</span>\")\n#-> HTL(\"<span><custom>a&amp;b</custom></span>\")\n\ndump(@htl(\"<span>$(Custom(\"a&b\"))</span>\"))\n#=>\nHTL\n  content: Array{Any}((3,))\n    1: String \"<span>\"\n    2: HypertextLiteral.ElementData\n      value: ….Custom\n        data: String \"a&b\"\n    3: String \"</span>\"\n=#","category":"page"},{"location":"#Quirks-and-Regression","page":"Tutorial","title":"Quirks & Regression","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Since this string format uses Julia macro processing, there are some differences between an htl literal and native Julia interpolation. For starters, Julia doesn't recognize and treat $ syntax natively for these macros, hence, at a very deep level parsing is different.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"\"$(\"Hello\")\"\n#-> \"Hello\"","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"In this interpolation, the expression \"Hello\" is seen as a string, and hence Julia can produce the above output. However, Julia does not given this special treatment to string literals. Hence, if you try this expression using htl you'll get an error.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"$(\"Hello\")\"\n#-> ERROR: syntax: cannot juxtapose string literal","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"The above expression is seen by Julia as 3 tokens, htl\"$(\", followed by Hello, and then \"). This combination is a syntax error. One might correct this using triple strings.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"\"\"$(\"Hello\")\"\"\"\n#-> HTL(\"Hello\")","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Alternatively, in Julia v1.6+, one could use the HTL macro format.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"#? VERSION >= v\"1.6.0-DEV\"\n@htl \"$(\"Hello\")\"\n#-> HTL(\"Hello\")","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Before v1.6, we cannot reliably detect interpolated string literals using the @htl macro, so they are errors (when we can detect them).","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"#? VERSION < v\"1.6.0-DEV\"\n@print @htl \"Look, Ma, $(\"<i>automatic escaping</i>\")!\"\n#-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"However, you can fix by wrapping a value in a string function.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print @htl \"Look, Ma, $(string(\"<i>automatic escaping</i>\"))!\"\n#-> Look, Ma, &#60;i>automatic escaping&#60;/i>!","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"The string literal style is not without its quirks. See @raw_str for exceptional cases where a slash immediately precedes the double quote. This is one case where the htl string macro cannot be made to work in a manner identical to regular string interpolation.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"\\\\\\\"\\n\"\n#-> HTL(\"\\\"\\n\")\n\n@htl(\"\\\\\\\"\\n\")\n#-> HTL(\"\\\\\\\"\\n\")","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"In Julia, to support regular expressions and other formats, string literals don't provide regular escaping semantics. This package adds those semantics.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"Hello\\World\"\n#-> ERROR: LoadError: ArgumentError: invalid escape sequence⋮\n\n@htl \"Hello\\World\"\n#-> ERROR: syntax: invalid escape sequence⋮","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Escaped strings should just pass-though.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"\\\"\\\\\\n\"\n#-> HTL(\"\\\"\\\\\\n\")\n\n@htl(\"\\\"\\\\\\n\")\n#-> HTL(\"\\\"\\\\\\n\")","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Within attributes, independent of quoting style, other datatypes are treated as an error. This includes Vector as well as HTL objects.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"<tag att='$([1,2,3])'\"\n#=>\nERROR: DomainError with [1, 2, 3]:\n  Unable to convert Vector{Int64} for use as an attribute value;\n  convert to a string or, for a specific attribute, implement a\n  `Base.show` method using `HTLAttribute` (and `htl_escape`)\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Within an unquoted attribute value, we must escape whitespace, the ampersand (&), quotation (\"), greater-than (>), less-than (<), apostrophe ('), grave accent (`), and equals (=) characters.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":" escape_me = \" \\t\\n\\\"&><'`=\"\n\n @print htl\"<tag quot=$escape_me/>\"\n #-> <tag quot=&#32;&#9;&#10;&#34;&#38;&#62;&#60;&#39;&#96;&#61;/>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Symbols are also properly handled; e.g. escaping happens after conversion of numbers, symbols and custom types to strings.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"\"\"<tag att=$(Symbol(\">3\"))>$(Symbol(\"a&b\"))</tag>\"\"\"\n#-> <tag att=&#62;3>a&#38;b</tag>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Interpolation should handle splat operator by concatenating results.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"$([x for x in [1,2,3]]...)\"\n#-> 123\n\n@print @htl \"$([x for x in [1,2,3]]...)\"\n#-> 123","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"However, it shouldn't concatenate lists by default, or assume treatment of any other sorts of native Julia objects.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"$([x for x in 1:3])\"\n#=>\nERROR: DomainError with [1, 2, 3]:\n  Type Vector{Int64} lacks a show method for text/html.\n  Perhaps use splatting? e.g. htl\"$([x for x in 1:3]...)\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"The script and style tags use a \"raw text\" encoding where all content up-to the end tag is not escaped using ampersands.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"book = \"Strunk & White\"\n@print htl\"\"\"<script>var book = \"$book\"</script>\"\"\"\n#-> <script>var book = \"Strunk & White\"</script>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"We throw an error if the end tag is accidently included.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"bad = \"</style>\"\n\nhtl\"\"\"<style>$bad</style>\"\"\"\n#=>\nERROR: DomainError with \"</style>\":\n  Content of <style> cannot contain the end tag (`</style>`).\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Attribute names should be non-empty and not in a list of excluded characters.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@htl(\"<tag $(\"\" => \"value\")/>\")\n#=>\nERROR: DomainError with :\nAttribute name must not be empty.\n=#\n\n@htl(\"<tag $(\"&att\" => \"value\")/>\")\n#=>\nERROR: DomainError with &att:\nInvalid character ('&') found within an attribute name.\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Unquoted interpolation adjacent to a raw string is also an error.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"<tag bare=literal$(:invalid)\"\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#\n\nhtl\"<tag bare=$(invalid)literal\"\n#=>\nERROR: LoadError: DomainError with bare=invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"We limit string interpolation to symbols or parenthesized expressions. For more details on this see Julia #37817.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"htl\"$[1,2,3]\"\n#=>\nERROR: LoadError: DomainError with [1, 2, 3]:\ninterpolations must be symbols or parenthesized⋮\n=#\n\n@htl(\"$[1,2,3]\")\n#=>\nERROR: syntax: invalid interpolation syntax: \"$[\"⋮\n=#","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Before Julia v1.6 (see issue #38501), string literals should not be used within the macro style since we cannot reliably detect them.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"x = \"\"\n\n@print htl\"\"\"$x$(\"<script>alert('Hello')</script>\")\"\"\"\n#-> &#60;script>alert('Hello')&#60;/script>\n\n#? VERSION >= v\"1.6.0-DEV\"\n@print htl\"\"\"$x$(\"<script>alert('Hello')</script>\")\"\"\"\n#-> &#60;script>alert('Hello')&#60;/script>\n\n#? VERSION < v\"1.6.0-DEV\"\n@print @htl(\"$x$(\"<script>alert(\\\"Hello\\\")</script>\")\")\n#-> <script>alert(\"Hello\")</script>","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Hence, for a cases where we could detect a string literal, we raise an error condition to discourage its use. The string macro form works.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"\"\"<tag>$(\"escape&me\")</tag>\"\"\"\n#-> <tag>escape&#38;me</tag>\n\n#? VERSION >= v\"1.6.0-DEV\"\n@print @htl \"<tag>$(\"escape&me\")</tag>\"\n#-> <tag>escape&#38;me</tag>\n\n#? VERSION < v\"1.6.0-DEV\"\n@print @htl \"<tag>$(\"escape&me\")</tag>\"\n#-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"A string ending with $ is an syntax error since it is an incomplete interpolation.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"@print htl\"$\"\n#-> ERROR: LoadError: \"missing interpolation expression\"⋮\n\n@print htl\"Foo$\"\n#-> ERROR: LoadError: \"missing interpolation expression\"⋮","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Here's something that perhaps should work... but fails currently.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"# htl\"<div $(:dataValue=>42, \"data-style\"=>:green)/>","category":"page"},{"location":"#Contributing","page":"Tutorial","title":"Contributing","text":"","category":"section"},{"location":"","page":"Tutorial","title":"Tutorial","text":"We are absolutely open to suggested improvements. This package is implemented according to several design criteria.","category":"page"},{"location":"","page":"Tutorial","title":"Tutorial","text":"Operation of interpolated expressions ($) should mirror what they would do with regular Julia strings, updated with hypertext escaping sensibilities including proper escaping and helpful representations.\nWith exception of boolean attributes (which must be removed to be false), input is treated as-is and not otherwise modified.\nInterpolations having string values are injected \"as-is\" into the output (subject to context sensitive checking or escaping); conversely, non-string values may be given helpful interpretations.\nGiven that this library will be used by content producers, it should be conservative, raising an error when invalid hypertext is discovered and only serializing Julia objects that have an express representation.\nThere should be an extension API that permits custom data types to provide their own context-sensitive serialization strategies.\nAs much processing (e.g. hypertext lexical analysis) should be done during macro expansion to reduce runtime and to report errors early. Error messages should guide the user towards addressing the problem.\nTo be helpful, HTML tags and attributes may be recognized. Special behavior may be provided to attributes such as \"style\" (CSS), \"class\" and, eventually, \"script\".\nFull coverage of HTML syntax is ideal, but unnecessary.","category":"page"}]
}

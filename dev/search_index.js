var documenterSearchIndex = {"docs":
[{"location":"attribute/#Attributes-and-Style","page":"Attributes & Style","title":"Attributes & Style","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Interpolation within single and double quoted attribute values are supported. Regardless of context, all four characters, <, &, ', and \" are escaped.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"using HypertextLiteral\n\nqval = \"\\\"&'\"\n\n@htl(\"\"\"<tag double=\"$qval\" single='$qval' />\"\"\")\n#-> <tag double=\"&quot;&amp;&apos;\" single='&quot;&amp;&apos;' />","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Unquoted or bare attributes are also supported. These are serialized using the single quoted style so that spaces and other characters do not need to be escaped.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"arg = \"book='Strunk & White'\"\n\n@htl(\"<tag bare=$arg />\")\n#-> <tag bare='book=&apos;Strunk &amp; White&apos;' />","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"In this document, we discuss interpolation within attribute values.","category":"page"},{"location":"attribute/#Boolean-Attributes","page":"Attributes & Style","title":"Boolean Attributes","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Within bare attributes, boolean values provide special support for boolean HTML properties, such as \"disabled\". When a value is false, the attribute is removed. When the value is true then the attribute is kept, with value being an empty string ('').","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl(\"<button disabled=$(true)>Disabled</button>\")\n#-> <button disabled=''>Disabled</button>\n\n@htl(\"<button disabled=$(false)>Clickable</button>\")\n#-> <button>Clickable</button>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Within a quoted attribute, boolean values are printed as-is.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl(\"<input type='text' value='$(true)'>\")\n#-> <input type='text' value='true'>\n\n@htl(\"<input type='text' value='$(false)'>\")\n#-> <input type='text' value='false'>","category":"page"},{"location":"attribute/#Nothing","page":"Attributes & Style","title":"Nothing","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Within bare attributes, nothing is treated as false, and the attribute is removed.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl(\"<button disabled=$(nothing)>Clickable</button>\")\n#-> <button>Clickable</button>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Within quoted attributes, nothing is treated as the empty string.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl(\"<input type='text' value='$(nothing)'>\")\n#-> <input type='text' value=''>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"This is designed for consistency with nothing within element content.","category":"page"},{"location":"attribute/#Vectors","page":"Attributes & Style","title":"Vectors","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Vectors and tuples are flattened using the space as a separator.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"class = [\"text-center\", \"text-left\"]\n\n@htl(\"<div class=$class>...</div>\")\n#-> <div class='text-center text-left'>...</div>\n\n@htl(\"<div class='$class'>...</div>\")\n#-> <div class='text-center text-left'>...</div>\n\n@htl(\"<tag att=$([:one, [:two, \"three\"]])/>\")\n#-> <tag att='one two three'/>\n\n@htl(\"<tag att='$((:one, (:two, \"three\")))'/>\")\n#-> <tag att='one two three'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"This behavior supports attributes having name tokens, such as Cascading Style Sheets' \"class\".","category":"page"},{"location":"attribute/#Pairs-and-Dictionaries","page":"Attributes & Style","title":"Pairs & Dictionaries","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Pairs, named tuples, and dictionaries are given treatment to support attributes such as CSS's \"style\".","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"style = Dict(:padding_left => \"2em\", :width => \"20px\")\n\n@htl(\"<div style=$style>...</div>\")\n#-> <div style='padding-left: 2em; width: 20px;'>...</div>\n\n@htl(\"<div style='font-size: 25px; $(:padding_left=>\"2em\")'/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@htl(\"<div style=$((padding_left=\"2em\", width=\"20px\"))/>\")\n#-> <div style='padding-left: 2em; width: 20px;'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"For each pair, keys are separated from their value with a colon (:). Adjacent pairs are delimited by the semi-colon (;). Moreover, for Symbol keys, snake_case values are converted to kebab-case.","category":"page"},{"location":"attribute/#General-Case","page":"Attributes & Style","title":"General Case","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Beyond these rules for booleans, nothing, and collections, values are reproduced with their print representation.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl(\"<div att=$((:a_symbol, \"string\", 42, 3.1415))/>\")\n#-> <div att='a_symbol string 42 3.1415'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"This permits the serialization of all sorts of third party objects.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"using Hyperscript\n\ntypeof(2em)\n#-> Hyperscript.Unit{:em, Int64}\n\n@htl \"<div style=$((border=2em,))>...</div>\"\n#-> <div style='border: 2em;'>...</div>","category":"page"},{"location":"attribute/#Extensions","page":"Attributes & Style","title":"Extensions","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Often times the default print representation of a custom type isn't desirable for use inside an attribute value.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"struct Custom data::String end\n\n@htl \"<tag att=$(Custom(\"A&B\"))/>\"\n#-> <tag att='…Custom(&quot;A&amp;B&quot;)'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"This can be sometimes addressed by implementing Base.print().","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Base.print(io::IO, c::Custom) = print(io, c.data)\n\nprint(@htl \"<tag att=$(Custom(\"A&B\"))/>\")\n#-> <tag att='A&amp;B'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"However, sometimes this isn't possible or desirable. A tailored representation specifically for use within an attribute_value can be provided.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"HypertextLiteral.attribute_value(x::Custom) = x.data\n\n@htl \"<tag att=$(Custom(\"A&B\"))/>\"\n#-> <tag att='A&amp;B'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Like content extensions, Bypass and Reprint work identically.","category":"page"},{"location":"attribute/#Inside-a-Tag","page":"Attributes & Style","title":"Inside a Tag","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Attributes may also be provided by any combination of dictionaries, named tuples, and pairs. Attribute names are normalized, where snake_case becomes kebab-case. We do not convert camelCase due to XML (MathML and SVG) attribute case sensitivity. Moreover, String attribute names are passed along as-is.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"attributes = Dict(:data_style => :green, \"data_value\" => 42, )\n\n@htl(\"<div $attributes/>\")\n#-> <div data-style='green' data_value='42'/>\n\n@htl(\"<div $(:data_style=>:green) $(:dataValue=>42)/>\")\n#-> <div data-style='green' dataValue='42'/>\n\n@htl(\"<div $((:data_style=>:green, \"data_value\"=>42))/>\")\n#-> <div data-style='green' data_value='42'/>\n\n@htl(\"<div $((data_style=:green, dataValue=42))/>\")\n#-> <div data-style='green' dataValue='42'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"A Pair inside a tag is treated as an attribute.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<div $(:data_style => \"green\")/>\"\n#-> <div data-style='green'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"A Symbol or String inside a tag is an empty attribute.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<div $(:data_style)/>\"\n#-> <div data-style=''/>\n\n#? VERSION >= v\"1.6.0-DEV\"\n@htl \"<div $(\"data_style\")/>\"\n#-> <div data_style=''/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"To expand an object into a set of attributes, implement inside_tag(). For example, let's suppose we have an object that represents both a list of CSS classes and a custom style.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"using HypertextLiteral: attribute_pair, Reprint\n\nstruct CustomCSS class::Vector{Symbol}; style end\n\nHypertextLiteral.inside_tag(s::CustomCSS) = begin\n    myclass = join((string(x) for x in s.class), \" \")\n    Reprint() do io::IO\n        print(io, attribute_pair(:class, myclass))\n        print(io, attribute_pair(:style, s.style))\n    end\nend\n\nstyle = CustomCSS([:one, :two], :background_color => \"#92a8d1\")\n\nprint(@htl \"<div $style>Hello</div>\")\n#-> <div class='one two' style='background-color: #92a8d1;'>Hello</div>","category":"page"},{"location":"attribute/#Style-Tag","page":"Attributes & Style","title":"Style Tag","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Within a <style> tag, Julia values are interpolated using the same rules as they would be if they were encountered within an attribute value, only that ampersand escaping is not done.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"style = Dict(:padding_left => \"2em\", :width => \"20px\")\n\n@htl \"\"\"<style>span {$style}</style>\"\"\"\n#-> <style>span {padding-left: 2em; width: 20px;}</style>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"In this context, content is validated to ensure it doesn't contain \"</style>\".","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"expr = \"\"\"<style>span {display: inline;}</style>\"\"\"\n\n@htl \"<style>$expr</style>\"\n#-> …ERROR: \"Content within a style tag must not contain `</style>`\"⋮","category":"page"},{"location":"attribute/#Edge-Cases","page":"Attributes & Style","title":"Edge Cases","text":"","category":"section"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Attribute names should be non-empty and not in a list of excluded characters.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag $(\"\" => \"value\")/>\"\n#-> ERROR: LoadError: \"Attribute name must not be empty.\"⋮\n\n@htl \"<tag $(\"&att\" => \"value\")/>\"\n#=>\nERROR: LoadError: DomainError with &att:\nInvalid character ('&') found within an attribute name.⋮\n=#","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"We don't permit adjacent unquoted attribute values.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl(\"<tag bare=$(true)$(:invalid)\")\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Unquoted interpolation adjacent to a raw string is also an error.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl(\"<tag bare=literal$(:invalid)\")\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#\n\n@htl(\"<tag bare=$(invalid)literal\")\n#=>\nERROR: LoadError: DomainError with bare=literal:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Ensure that dictionary style objects are serialized. See issue #7.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"let\n    h = @htl(\"<div style=$(Dict(\"color\" => \"red\"))>asdf</div>\")\n    repr(MIME\"text/html\"(), h)\nend\n#-> \"<div style='color: red;'>asdf</div>\"","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Let's ensure that attribute values in a dictionary are escaped.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag escaped=$(Dict(:esc=>\"'&\\\"<\"))/>\"\n#-> <tag escaped='esc: &apos;&amp;&quot;&lt;;'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"When we normalize attribute names, we strip leading underscores.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag $(:__att => :value)/>\"\n#-> <tag att='value'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"We don't expand into attributes things that don't look like attributes.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag $(3)/>\"\n#-> ERROR: MethodError: no method matching inside_tag(::Int64)⋮","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"One can add additional attributes following a bare name.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag bing $(:att)/>\"\n#-> <tag bing att=''/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Inside a tag, tuples can have many kinds of pairs.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"a1 = \"a1\"\n@htl \"<tag $((a1,:a2,:a3=3,a4=4))/>\"\n#-> <tag a1='' a2='' a3='3' a4='4'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"The macro attempts to expand attributes inside a tag. To ensure the runtime dispatch also works, let's do a few things once indirect.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"hello = \"Hello\"\ndefer(x) = x\n\n@htl \"<tag $(defer(:att => hello))/>\"\n#-> <tag att='Hello'/>\n\n@htl \"<tag $(defer((att=hello,)))/>\"\n#-> <tag att='Hello'/>\n\n@htl \"<tag $(:att => defer(hello))/>\"\n#-> <tag att='Hello'/>\n\n@htl \"<tag $(defer(:att) => hello)/>\"\n#-> <tag att='Hello'/>","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"It's a lexing error to have an attribute lacking a name.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag =value/>\"\n#=>\nERROR: LoadError: DomainError with  =value/>:\nunexpected equals sign before attribute name⋮\n=#","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"It's a lexing error to have an attribute lacking a value.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag att=>\"\n#=>\nERROR: LoadError: DomainError with =>:\nmissing attribute value⋮\n=#","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Attribute names and values can be spaced out.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag one two = value />\"\n#-> <tag one two = value />","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Invalid attribute names are reported.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<tag at<ribute='val'/>\"\n#=>\nERROR: LoadError: DomainError with t<ribute=…\nunexpected character in attribute name⋮\n=#","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"While assignment operator is permitted in Julia string interpolation, we exclude it to guard it against accidently forgetting a comma.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"@htl \"<div $((data_value=42,))/>\"\n#-> <div data-value='42'/>\n\n@htl(\"<div $((data_value=42))/>\")\n#=>\nERROR: LoadError: DomainError with data_value = 42:\nassignments are not permitted in an interpolation⋮\n=#\n\n@htl(\"<div $(data_value=42)/>\")\n#=>\nERROR: LoadError: DomainError with data_value = 42:\nassignments are not permitted in an interpolation⋮\n=#","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"Interpolation of adjacent values should work.","category":"page"},{"location":"attribute/","page":"Attributes & Style","title":"Attributes & Style","text":"x = 'X'; y = 'Y';\n@htl(\"<span att='$x$y'/>\")\n#-> <span att='XY'/>","category":"page"},{"location":"design/#Design-Rationale","page":"Design Rationale","title":"Design Rationale","text":"","category":"section"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"This package is implemented according to several design criteria.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Operation of interpolated expressions ($) should (mostly) mirror what they would do with regular Julia strings, updated with hypertext escaping sensibilities including proper escaping.\nSpeed of construction is critically important. This library is intended to be used deep within systems that generate extensive number of very large reports, interactively or in batch.\nWith exception of boolean attributes (which must be removed to be false), templates are treated as-is and not otherwise modified.\nWithin <script>, support translation of Julia objects to JavaScript. Enable this translation to be used within on and other contexts via HypertextLiteral.js function.\nSince the style and class attributes are so important in HTML construction, interpretations of Julia constructs should support these CSS attributes.\nThere should be a discoverable and well documented extension API that permits custom data types to provide their own serialization strategies based upon syntactical context.\nAs much processing (e.g. hypertext lexical analysis) should be done during macro expansion to reduce runtime and to report errors early. We'll be slightly slower on interactive use to be fast in batch.\nFull coverage of HTML syntax or reporting syntax or semantic errors within the HTML content is not a goal.","category":"page"},{"location":"design/#Specific-Design-Decisions","page":"Design Rationale","title":"Specific Design Decisions","text":"","category":"section"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Besides implementing show, we also provide serialization when printing to \"text/html\" mime types.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"using HypertextLiteral\n\n@htl \"<span>Hello World</span>\"\n#-> <span>Hello World</span>\n\ndisplay(\"text/html\", @htl \"<span>Hello World</span>\")\n#-> <span>Hello World</span>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"We wrap missing and other data types using a <span> tag as they are printed. This permits customized CSS to control their presentation.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<tag>$(missing)</tag>\"\n#-> <tag><span class=\"Base-Missing\">missing</span></tag>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Julia's regular interpolation stringifies everything. Instead, we treat a Vector as a sequence to be concatenated. Within attributes, vectors are space separated.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"$([x for x in 1:3])\"\n#-> 123\n\n@htl \"<tag att=$([x for x in 1:3])/>\"\n#-> <tag att='1 2 3'/>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"We treat nothing as being empty. This is true for both element content and attribute values.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<span>$(nothing)</span>\"\n#-> <span></span>\n\n@htl \"<tag att='$(nothing)'/>\"\n#-> <tag att=''/>","category":"page"},{"location":"design/#Notable-Features","page":"Design Rationale","title":"Notable Features","text":"","category":"section"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Attributes assigned a boolean value have specialized support.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<input type='checkbox' selected=$(false) disabled=$(true)></input>\"\n#-> <input type='checkbox' disabled=''></input>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Dictionaries are translated to support CSS within attributes and the <style> tag. In this case, snake_case symbols become kebab-case.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"style = Dict(:padding_left => \"2em\", :width => \"20px\")\n\n@htl(\"<div style='font-size: 25px; $style'>...</div>\")\n#-> <div style='font-size: 25px; padding-left: 2em; width: 20px;'>...</div>\n\n@htl \"<style>input {$style}</style>\"\n#-> <style>input {padding-left: 2em; width: 20px;}</style>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Within a <script> tag these macros provide a translation to Javascript.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"v = \"<1 Brown \\\"M&M's\\\"!\";\n\n@htl \"<script>v = $v</script>\"\n#-> <script>v = \"<1 Brown \\\"M&M's\\\"!\"</script>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"JavaScript translation can be accessed via the js function.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"using HypertextLiteral: js\n\n@htl \"<button onclick='alert($(js(\"M&M's\")))'>\"\n#-> <button onclick='alert(&quot;M&amp;M&apos;s&quot;)'>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"The @htl_str form is useful for dynamically constructed templates.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"templ = join(\"<td>\\$$x</td>\" for x in [:a,:b])\n#-> \"<td>\\$a</td><td>\\$b</td>\"\n\n(a, b) = (:A, :B);\n\neval(:(@htl_str($templ)))\n#-> <td>A</td><td>B</td>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Within element content, most datatypes are serialized within a <span> tag.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"using Dates\n\n@htl(\"<div>$(Date(\"2021-07-28\"))</div>\")\n#-> <div><span class=\"Dates-Date\">2021-07-28</span></div>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"This automatic wrapping permits CSS to be used to style output. For example, the following style will display missing as \"N/A\".","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"    <style>\n    span.Base-Missing {visibility: collapse;}\n    span.Base-Missing::before {content: \"N/A\"; visibility: visible;}\n    </style>","category":"page"},{"location":"design/#Lexer-Tests","page":"Design Rationale","title":"Lexer Tests","text":"","category":"section"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"There are several HTML syntax errors that we can detect as part of our parser. For example, you shouldn't put comments within a script tag.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl(\"<script><!-- comment --></script>\")\n#-> ERROR: LoadError: \"script escape or comment is not implemented\"⋮","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Our lexer currently doesn't bother with processor instructions or doctype declarations. You could prepend these before your content.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl(\"<?xml version='1.0'?>\")\n#=>\nERROR: LoadError: DomainError with <?xml ver…:\nunexpected question mark instead of tag name⋮\n=#\n\n@htl(\"<!DOCTYPE html>\")\n#-> ERROR: LoadError: \"DOCTYPE not supported\"⋮\n\n@htl(\"<![CDATA[No <b>CDATA</b> either.]]>\")\n#-> ERROR: LoadError: \"CDATA not supported\"⋮","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"It's a lexing error to have an attribute lacking a name.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<tag =value/>\"\n#=>\nERROR: LoadError: DomainError with  =value/>:\nunexpected equals sign before attribute name⋮\n=#","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"It's a lexing error to have an attribute lacking a value.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<tag att=>\"\n#=>\nERROR: LoadError: DomainError with =>:\nmissing attribute value⋮\n=#","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Tags can be ended using SGML ending.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<tag></>\"\n#-> <tag></>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"We add an extra space to ensure adjacent values parse properly.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<tag $((:one))two=''/>\"\n#-> <tag one='' two=''/>\n\n@htl \"<tag $((:one))$((:two))/>\"\n#-> <tag one='' two=''/>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Attribute names and values can be spaced out.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<tag one two = value />\"\n#-> <tag one two = value />","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Invalid attribute names are reported.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<tag at<ribute='val'/>\"\n#=>\nERROR: LoadError: DomainError with t<ribute=…\nunexpected character in attribute name⋮\n=#","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Rawtext has a few interesting lexical cases.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"\"\"<style> </s </> </style>\"\"\"\n#-> <style> </s </> </style>\n\n@htl \"<style> </s </style/\"\n#=>\nERROR: LoadError: DomainError with e/:\nunexpected solidus in tag⋮\n=#\n\n@htl \"<style></style <\"\n#=>\nERROR: LoadError: DomainError with  <:\nunexpected character in attribute name⋮\n=#","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Comments can contain interpolated values.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"content = \"<!-- a&b -->\"\n\n@htl \"<!-- $content -->\"\n#-> <!-- &lt;!-- a&amp;b --> -->","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Empty comments are permitted.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<!---->\"\n#-> <!---->","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Comments should not exist within a script tag.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl(\"<script><!-- comment --></script>\")\n#-> ERROR: LoadError: \"script escape or comment is not implemented\"⋮","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Comments need to be well formed.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<!-> \"\n#=>\nERROR: LoadError: DomainError with !-> :\nincorrectly opened comment⋮\n=#\n\n@htl \"<!--> \"\n#=>\nERROR: LoadError: DomainError with -> :\nabrupt closing of empty comment⋮\n=#\n\n@htl \"<!---> \"\n#=>\nERROR: LoadError: DomainError with -> :\nabrupt closing of empty comment⋮\n=#","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Comments cannot contain a nested comment.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<!-- <!-- nested --> -->\"\n#=>\nERROR: LoadError: DomainError with - nested …:\nnested comment⋮\n=#","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Comments can contain content that is similar to a comment block, but the recognition of these valid states is rather involved.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<!-- <!-->\"\n#-> <!-- <!-->\n\n@htl \"<!--<x-->\"\n#-> <!--<x-->\n\n@htl \"<!--<!x!>-->\"\n#-> <!--<!x!>-->\n\n@htl \"<!--<!-x-->\"\n#-> <!--<!-x-->\n\n@htl \"<!---x-->\"\n#-> <!---x-->\n\n@htl \"<!--<<x-->\"\n#-> <!--<<x-->\n\n@htl \"<!-- - --! --- --!- -->\"\n#-> <!-- - --! --- --!- -->","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Not so sure about this lexical production... perhaps it's a transcription error from the specification?","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<!----!>\"\n#=>\nERROR: LoadError: DomainError with !>:\nnested comment⋮\n=#","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Even though actual content may be permitted in these odd spots, we don't generally permit interpolation.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<!--<$(:x)\"\n#=>\nERROR: LoadError: \"unexpected binding STATE_COMMENT_LESS_THAN_SIGN\"⋮\n=#","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"Of course, we could have pure content lacking interpolation, this also goes though the lexer.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"@htl \"<div>Hello<b>World</b>!</div>\"\n#-> <div>Hello<b>World</b>!</div>","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"However, this macro requires a string literal.","category":"page"},{"location":"design/","page":"Design Rationale","title":"Design Rationale","text":"f() = \"<div>Hello<b>World</b>!</div>\"\n\n@htl f()\n#=>\nERROR: LoadError: DomainError with f():\na string literal is required⋮\n=#","category":"page"},{"location":"content/#Element-Content","page":"Element Content","title":"Element Content","text":"","category":"section"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Hypertext literal provides interpolation via $. Within element content, the ampersand (&), less-than (<), single-quote (') and double-quote (\") are escaped.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"using HypertextLiteral\n\nbook = \"Strunk & White\"\n\n@htl \"<span>Today's Reading: $book</span>\"\n#-> <span>Today's Reading: Strunk &amp; White</span>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Julia expressions can be interpolated using the $(expr) notation.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"2+2 = $(2+2)\"\n#-> 2+2 = 4","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"To include $ in the output, use \\$. Other escape sequences, such as \\\" also work.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"They said, \\\"your total is \\$42.50\\\".\"\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Within tripled double-quotes, single double-quoted strings can go unescaped, however, we still need to escape the dollar sign ($).","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"\"\"They said, \"your total is \\$42.50\".\"\"\"\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"In this document, we discuss interpolation within regular tagged content. Interpolation within attribute values and within <script> or <style> tags is treated differently.","category":"page"},{"location":"content/#Strings-and-Numbers","page":"Element Content","title":"Strings & Numbers","text":"","category":"section"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Strings, symbols, integers, booleans, and floating point values are reproduced with their standard print() representation. Output produced in this way is properly escaped.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<enabled>$(false)</enabled><color>$(:blue)</color>\"\n#-> <enabled>false</enabled><color>blue</color>\n\n@htl \"<int>$(42)</int><float>$(6.02214076e23)</float>\"\n#-> <int>42</int><float>6.02214076e23</float>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"We include AbstractString for the performant serialization of SubString and other string-like objects.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<slice>$(SubString(\"12345\", 2:4))</slice>\"\n#-> <slice>234</slice>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"All other types, such as Irrational, have special treatment. Explicit conversion to a String is a simple way to avoid the remaining rules.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"#? VERSION >= v\"1.3.0-DEV\"\n@htl \"<value>$(string(π))</value>\"\n#-> <value>π</value>","category":"page"},{"location":"content/#HTML-Values","page":"Element Content","title":"HTML Values","text":"","category":"section"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Since values translated by the @htl macro are \"text/html\", they can be used in a nested manner, permitting us to build template functions.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"sq(x) = @htl(\"<span>$(x*x)</span>\")\n\n@htl \"<div>3^2 is $(sq(3))</div>\"\n#-> <div>3^2 is <span>9</span></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Values showable as \"text/html\" will bypass ampersand escaping.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<div>$(HTML(\"<span>unescaped 'literal'</span>\"))</div>\"\n#-> <div><span>unescaped 'literal'</span></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Custom datatypes can provide their own representation by implementing show for \"text/html\".","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"struct Showable data::String end\n\nfunction Base.show(io::IO, mime::MIME\"text/html\", c::Showable)\n    value = replace(replace(c.data, \"&\"=>\"&amp;\"), \"<\"=>\"&lt;\")\n    print(io, \"<showable>$(value)</showable>\")\nend\n\nprint(@htl \"<span>$(Showable(\"a&b\"))</span>\")\n#-> <span><showable>a&amp;b</showable></span>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"HypertextLiteral trusts that \"text/html\" content is properly escaped.","category":"page"},{"location":"content/#Nothing","page":"Element Content","title":"Nothing","text":"","category":"section"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Within element content, nothing is simply omitted.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<span>$nothing</span>\"\n#-> <span></span>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Use something() to provide an alternative representation.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<span>$(something(nothing, \"N/A\"))</span>\"\n#-> <span>N/A</span>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"This design supports template functions that return nothing.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"choice(x) = x ? @htl(\"<span>yes</span>\") : nothing\n\n@htl \"<div>$(choice(true))$(choice(false))</div>\"\n#-> <div><span>yes</span></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Note that missing has default treatment, see below.","category":"page"},{"location":"content/#Vectors-and-Tuples","page":"Element Content","title":"Vectors & Tuples","text":"","category":"section"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Within element content, vector and tuple elements are concatenated (with no delimiter).","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<tag>$([1,2,3])</tag>\"\n#-> <tag>123</tag>\n\n@htl \"<tag>$((1,2,3))</tag>\"\n#-> <tag>123</tag>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"This interpretation enables nesting of templates.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"books = [\"Who Gets What & Why\", \"Switch\", \"Governing The Commons\"]\n\n@htl \"<ul>$([@htl(\"<li>$b\") for b in books])</ul>\"\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"The splat operator (...) is supported as a noop.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"$([x for x in 1:3]...)\"\n#-> 123","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Generators are also treated in this manner.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"print(@htl \"<ul>$((@htl(\"<li>$b\") for b in books))</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"The map(container) do item; … ;end construct works and is performant.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<ul>$(map(books) do b @htl(\"<li>$b\") end)</ul>\"\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"content/#General-Case","page":"Element Content","title":"General Case","text":"","category":"section"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Within element content, values are wrapped in a <span> tag.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"\"\"<div>$missing</div>\"\"\"\n#-> <div><span class=\"Base-Missing\">missing</span></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"This wrapping lets CSS style output. The following renders missing as \"N/A\".","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"    <style>\n    span.Base-Missing {visibility: collapse;}\n    span.Base-Missing::before {content: \"N/A\"; visibility: visible;}\n    </style>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"The <span> tag's class attribute includes the module and type name.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"using Dates\n\n@htl \"<div>$(Date(\"2021-07-28\"))</div>\"\n#-> <div><span class=\"Dates-Date\">2021-07-28</span></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"This handwork is accomplished with a generated function when an object is not showable as \"text/html\". If the datatype's module is Main then it is not included in the class.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"struct Custom data::String; end\n\nBase.print(io::IO, c::Custom) = print(io, c.data)\n\nprint(@htl \"<div>$(Custom(\"a&b\"))</div>\")\n#-> <div><span class=\"Custom\">a&amp;b</span></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Bypassing <span> wrapping can be accomplished with string().","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"print(@htl \"<div>$(string(Custom(\"a&b\")))</div>\")\n#-> <div>a&amp;b</div>","category":"page"},{"location":"content/#Extensions","page":"Element Content","title":"Extensions","text":"","category":"section"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Sometimes it's useful to extend @htl so that it knows how to print your object without constructing this <span> wrapper. This can be done by implementing a method of the content() function.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"struct Custom data::String end\n\nHypertextLiteral.content(c::Custom) =\n    \"They said: '$(c.data)'\"\n\n@htl \"<div>$(Custom(\"Hello\"))</div>\"\n#-> <div>They said: &apos;Hello&apos;</div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"You can use @htl to produce tagged content.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"HypertextLiteral.content(c::Custom) =\n    @htl(\"<custom>$(c.data)</custom>\")\n\n@htl \"<div>$(Custom(\"a&b\"))</div>\"\n#-> <div><custom>a&amp;b</custom></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"With our primitives, you could have even more control. If your datatype builds its own tagged content, you can Bypass ampersand escaping.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"HypertextLiteral.content(c::Custom) =\n    HypertextLiteral.Bypass(\"<custom>$(c.data)</custom>\")\n\n@htl \"<div>$(Custom(\"Hello\"))</div>\"\n#-> <div><custom>Hello</custom></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Unfortunately, this won't escape the content of your custom object.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<div>$(Custom(\"<script>alert('whoops!);\"))</div>\"\n#-> <div><custom><script>alert('whoops!);</custom></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"The Reprint primitive can help with composite templates.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"using HypertextLiteral: Bypass, Reprint\n\nHypertextLiteral.content(c::Custom) =\n    Reprint(io::IO -> begin\n        print(io, Bypass(\"<custom>\"))\n        print(io, c.data)\n        print(io, Bypass(\"</custom>\"))\n    end)\n\nprint(@htl \"<div>$(Custom(\"a&b\"))</div>\")\n#-> <div><custom>a&amp;b</custom></div>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"In fact, the @htl macro produces exactly this translation.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"HypertextLiteral.content(c::Custom) =\n    @htl(\"<custom>$(c.data)</custom>\")\n\nprint(@htl \"<div>$(Custom(\"a&b\"))</div>\")\n#-> <div><custom>a&amp;b</custom></div>","category":"page"},{"location":"content/#Edge-Cases","page":"Element Content","title":"Edge Cases","text":"","category":"section"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Within element content, even though it isn't strictly necessary, we ampersand escape the single and double quotes.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"v = \"<'\\\"&\"\n\n@htl \"<span>$v</span>\"\n#-> <span>&lt;&apos;&quot;&amp;</span>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Symbols are likewise escaped.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"v = Symbol(\"<'\\\"&\")\n\n@htl \"<span>$v</span>\"\n#-> <span>&lt;&apos;&quot;&amp;</span>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Interpolation within the xmp, iframe, noembed, noframes, and noscript tags are not supported.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"<iframe>$var</iframe>\"\n#=>\nERROR: LoadError: DomainError with iframe:\nOnly script and style rawtext tags are supported.⋮\n=#","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"String escaping by @htl is handled by Julia itself.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"\\\"\\t\\\\\"\n#-> \"\t\\\n\n@htl \"(\\\\\\\")\"\n#-> (\\\")","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Literal content can contain Unicode values.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"x = \"Hello\"\n\n@htl \"⁅$(x)⁆\"\n#-> ⁅Hello⁆","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Escaped content may also contain Unicode.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"x = \"⁅Hello⁆\"\n\n@htl \"<tag>$x</tag>\"\n#-> <tag>⁅Hello⁆</tag>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"String interpolation is limited to symbols or parenthesized expressions (see Julia #37817).","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl(\"$[1,2,3]\")\n#=>\nERROR: syntax: invalid interpolation syntax: \"$[\"⋮\n=#\n\n@htl(\"$(1,2,3)\")\n#=>\nERROR: syntax: invalid interpolation syntax⋮\n=#","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Before v1.6, we cannot reliably detect string literals using the @htl macro, so they are errors (when we can detect them).","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"#? VERSION < v\"1.6.0-DEV\"\n@htl \"Look, Ma, $(\"<i>automatic escaping</i>\")!\"\n#-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮\n\n#? VERSION < v\"1.6.0-DEV\"\n@htl \"$(\"even if they are the only content\")\"\n#-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"However, you can fix by wrapping a value in a string function.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"@htl \"Look, Ma, $(string(\"<i>automatic escaping</i>\"))!\"\n#-> Look, Ma, &lt;i>automatic escaping&lt;/i>!","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"In particular, before v1.6, there are edge cases where unescaped string literal is undetectable and content can leak.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"x = \"\"\n\n#? VERSION < v\"1.6.0-DEV\"\n@htl \"$x$(\"<script>alert(\\\"Hello\\\")</script>\")\"\n#-> <script>alert(\"Hello\")</script>","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"Julia #38501 was fixed in v1.6.","category":"page"},{"location":"content/","page":"Element Content","title":"Element Content","text":"#? VERSION >= v\"1.6.0-DEV\"\n@htl \"<tag>$(\"escape&me\")</tag>\"\n#-> <tag>escape&amp;me</tag>","category":"page"},{"location":"primitives/#Escaping-Primitives","page":"Escaping Primitives","title":"Escaping Primitives","text":"","category":"section"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"This is a regression test for components upon which HTL is constructed, the design centers around EscapeProxy which escapes content printed to it. There are several wrappers which drive special proxy handling.","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"using HypertextLiteral: EscapeProxy, Bypass, Reprint, Render","category":"page"},{"location":"primitives/#EscapeProxy","page":"Escaping Primitives","title":"EscapeProxy","text":"","category":"section"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"This utility class acts wraps an IO stream to provide HTML escaping.","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"io = IOBuffer()\nep = EscapeProxy(io)\n\nmacro echo(expr)\n    :($expr; print(String(take!(io))))\nend","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"The result of this proxy is that regular content printed to it is passed along to the wrapped IO, after escaping the ampersand (&), less-than (<), single-quote ('), and double-quote (\").","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"@echo print(ep, \"(&'<\\\")\")\n#-> (&amp;&apos;&lt;&quot;)","category":"page"},{"location":"primitives/#Bypass","page":"Escaping Primitives","title":"Bypass","text":"","category":"section"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"This wrapper simply prints its content.","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"print(Bypass(\"<tagged/>\"))\n#-> <tagged/>","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"Printed content wrapped with Bypass is not subject to escaping.","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"@echo print(ep, Bypass(\"<span>\"), \"<A&B>\", Bypass(\"</span>\"))\n#-> <span>&lt;A&amp;B></span>","category":"page"},{"location":"primitives/#Reprint","page":"Escaping Primitives","title":"Reprint","text":"","category":"section"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"This wrapper holds a closure that prints to an io.","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"print(Reprint(io::IO -> print(io, \"Hello World\")))\n#-> Hello World","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"Reprinted content is still subject to escaping.","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"@echo print(ep, Reprint(io -> print(io, \"(&'<\\\")\")))\n#-> (&amp;&apos;&lt;&quot;)","category":"page"},{"location":"primitives/#Render","page":"Escaping Primitives","title":"Render","text":"","category":"section"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"This wrapper prints text/html display of an object.","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"struct Custom\n    content\nend\n\nBase.show(io::IO, m::MIME\"text/html\", c::Custom) =\n   print(io, c.content)\n\nprint(Render(Custom(\"<tag/>\")))\n#-> <tag/>","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"The printed content is not subject to escaping.","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"@echo print(ep, Render(Custom(\"<tag/>\")))\n#-> <tag/>","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"It's an error if the wrapped object isn't showable to \"text/html\".","category":"page"},{"location":"primitives/","page":"Escaping Primitives","title":"Escaping Primitives","text":"print(Render(\"This is an error!\"))\n#-> ERROR: MethodError: … show(… ::MIME{Symbol(\"text/html\")}⋮","category":"page"},{"location":"script/#Script-Interpolation","page":"Script Interpolation","title":"Script Interpolation","text":"","category":"section"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Within a <script> tag, Julia values are serialized to their equivalent Javascript.  String literal values are rendered as double-quoted values.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"using HypertextLiteral\n\nv = \"\"\"Brown \"M&M's\"!\"\"\";\n\n@htl \"<script>var x = $v</script>\"\n#-> <script>var x = \"Brown \\\"M&M's\\\"!\"</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Julia tuples and vectors are serialized as Javascript array. Integers, boolean, and floating point values are handled. As special cases, nothing is represented using undefined and missing using null.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"v = Any[true, 1, 1.0, nothing, missing]\n\n@htl \"<script>var x = $v</script>\"\n#-> <script>var x = [true, 1, 1.0, undefined, null]</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"This translation attempts to convert numbers properly.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"v = (-Inf, Inf, NaN, 6.02214e23)\n\n@htl \"<script>var x = $v</script>\"\n#-> <script>var x = [-Infinity, Infinity, NaN, 6.02214e23]</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Dictionaries are serialized as a Javascript object. Symbols are converted to string values.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"v = Dict(:min=>1, :max=>8)\n\n@htl \"<script>var x = $v</script>\"\n#-> <script>var x = {\"max\": 8, \"min\": 1}</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Besides dictionary objects, we support named tuples.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"v = (min=1, max=8)\n\n@htl \"<script>var x = $v</script>\"\n#-> <script>var x = {\"min\": 1, \"max\": 8}</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"String values are escaped to avoid <script>, </script>, and <!--.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"content = \"\"\"<script>alert(\"no injection!\")</script>\"\"\"\n\n@htl \"<script>v = $content</script>\"\n#-> <script>v = \"<\\script>alert(\\\"no injection!\\\")<\\/script>\"</script>\n\ncontent = \"\"\"--><!-- no injection!\"\"\"\n\n@htl \"<script>v = $content</script>\"\n#-> <script>v = \"--><\\!-- no injection!\"</script>","category":"page"},{"location":"script/#JavaScript","page":"Script Interpolation","title":"JavaScript","text":"","category":"section"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Sometimes you already have content that is valid Javascript. This can be printed directly, without escaping using a wrapper similar to HTML:","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"using HypertextLiteral: JavaScript\n\nexpr = JavaScript(\"\"\"console.log(\"Hello World\")\"\"\")\n\n@htl \"<script>$expr</script>\"\n#-> <script>console.log(\"Hello World\")</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"The JavaScript wrapper indicates the content should be directly displayed within a \"text/javascript\" context. We try to catch content which is not properly escaped for use within a <script> tag.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"expr = \"\"\"<script>console.log(\"Hello World\")</script>\"\"\"\n\n@htl \"<script>$(JavaScript(expr))</script>\"\n#-> …ERROR: \"Content within a script tag must not contain `</script>`\"⋮","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Similarly, a comment sequence is also forbidden.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"expr = \"<!-- invalid comment -->\"\n\n@htl \"<script>$(JavaScript(expr))</script>\"\n#-> …ERROR: \"Content within a script tag must not contain `<!--`\"⋮","category":"page"},{"location":"script/#Script-Attributes","page":"Script Interpolation","title":"Script Attributes","text":"","category":"section"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Conversion of Julia values to JavaScript can be performed explicitly within attributes using js(), which is not exported by default.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"using HypertextLiteral: js\n\nv = \"\"\"Brown \"M&M's\"!\"\"\";\n\n@htl \"<div onclick='alert($(js(v)))'>\"\n#-> <div onclick='alert(&quot;Brown \\&quot;M&amp;M&apos;s\\&quot;!&quot;)'>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"The js() function can be used independently.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"msg = \"alert($(js(v)))\"\n\n@htl \"<div onclick=$msg>\"\n#-> <div onclick='alert(&quot;Brown \\&quot;M&amp;M&apos;s\\&quot;!&quot;)'>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Although strictly unnecessary, slash escaping to prevent <\\script> content is still provided.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"v = \"<script>nested</script>\"\n\n@htl \"<div onclick='alert($(js(v)))'>\"\n#-> <div onclick='alert(&quot;&lt;\\script>nested&lt;\\/script>&quot;)'>","category":"page"},{"location":"script/#Extensions","page":"Script Interpolation","title":"Extensions","text":"","category":"section"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"If an object is not showable as \"text/javascript\" then you will get the following exception.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"@htl(\"<script>$(π)</script>\")\n#-> …ERROR: \"Irrational{:π} is not showable as text/javascript\"⋮","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"This can be overcome with a show() method for \"text/javascript\",","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"struct Log\n    data\nend\n\nfunction Base.show(io::IO, mime::MIME\"text/javascript\", c::Log)\n    print(io, \"console.log(\", c.data, \")\")\nend","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Like the HTML wrapper, you take full control of ensuring this content is relevant to the context.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"print(@htl \"\"\"<script>$(Log(missing))</script>\"\"\")\n#-> <script>console.log(missing)</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Alternatively, one could implement print_script, recursively calling this function on datatypes which require further translation.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"import HypertextLiteral: print_script\n\nfunction print_script(io::IO, c::Log)\n    print(io, \"console.log(\")\n    print_script(io, c.data)\n    print(io, \")\")\nend\n\nprint(@htl \"\"\"<script>$(Log(missing))</script>\"\"\")\n#-> <script>console.log(null)</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"This method is how we provide support for datatypes in Base without committing type piracy by implementing show for \"text/javascript\".","category":"page"},{"location":"script/#Edge-Cases","page":"Script Interpolation","title":"Edge Cases","text":"","category":"section"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"Within a <script> tag, comment start (<!--) must also be escaped. Moreover, capital <Script> and permutations are included. We only scan the first character after the left-than (<) symbol, so there may be strictly unnecessary escaping.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"v = \"<!-- <Script> <! 3<4 </ <s !>\"\n\n@htl \"<script>var x = $v</script>\"\n#-> <script>var x = \"<\\!-- <\\Script> <\\! 3<4 <\\/ <\\s !>\"</script>","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"It's important to handle unicode content properly.","category":"page"},{"location":"script/","page":"Script Interpolation","title":"Script Interpolation","text":"s = \"α\\n\"\n\n@htl(\"<script>alert($(s))</script>\")\n#-> <script>alert(\"α\\n\")</script>","category":"page"},{"location":"reference/#Package-Reference","page":"Package Reference","title":"Package Reference","text":"","category":"section"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"Modules = [HypertextLiteral]\nPrivate = true","category":"page"},{"location":"reference/#HypertextLiteral.HypertextLiteral","page":"Package Reference","title":"HypertextLiteral.HypertextLiteral","text":"HypertextLiteral\n\nThe HypertextLiteral module exports the @htl macro which implements interpolation aware of hypertext escape context. It also provides for escaping of JavaScript within the <script> tag.\n\njulia> v = \"<1 Brown \\\"M&M's\\\"!\";\n\njulia> @htl \"<span>$v</span>\"\n<span>&lt;1 Brown &quot;M&amp;M&apos;s&quot;!</span>\n\njulia> @htl \"<script>console.log($v)</script>\"\n<script>console.log(\"<1 Brown \\\"M&M's\\\"!\")</script>\n\nThis escaping of Julia values to JavaScript values is done with js function, which is not exported by default.\n\njulia> v = \"<1 Brown \\\"M&M's\\\"!\";\n\njulia> @htl \"<div onclick='alert($(HypertextLiteral.js(v)))'>\"\n<div onclick='alert(&quot;&lt;1 Brown \\&quot;M&amp;M&apos;s\\&quot;!&quot;)'>\n\nThere is also a non-standard string literal, @htl_str that is not exported. It can be used with dynamically constructed templates.\n\nSee also: @htl, HypertextLiteral.@htl_str\n\n\n\n\n\n","category":"module"},{"location":"reference/#HypertextLiteral.EscapeProxy","page":"Package Reference","title":"HypertextLiteral.EscapeProxy","text":"EscapeProxy(io) - wrap an `io` to perform HTML escaping\n\nThis is a transparent proxy that performs HTML escaping so that objects that are printed are properly converted into valid HTML values. As a special case, objects wrapped with Bypass are not escaped, and bypass the proxy.\n\nExamples\n\njulia> ep = EscapeProxy(stdout);\njulia> print(ep, \"A&B\")\nA&amp;B\njulia> print(ep, Bypass(\"<tag/>\"))\n<tag/>\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.JavaScript","page":"Package Reference","title":"HypertextLiteral.JavaScript","text":"JavaScript(js) - shows `js` as `\"text/javascript\"`\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Render","page":"Package Reference","title":"HypertextLiteral.Render","text":"Render(data) - printed object shows its text/html\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Reprint","page":"Package Reference","title":"HypertextLiteral.Reprint","text":"Reprint(fn) - apply the lambda function when printed\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Result","page":"Package Reference","title":"HypertextLiteral.Result","text":"Result(fn)\n\nThis object wraps a function produced by the @htl macro. This function prints a the evaluated to the given io. This object is also showable via \"text/html\" so it may be used in an HTML display context.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Script","page":"Package Reference","title":"HypertextLiteral.Script","text":"Script(data)\n\nThis object renders Javascript data escaped within an attribute.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.ScriptTag","page":"Package Reference","title":"HypertextLiteral.ScriptTag","text":"ScriptTag(data)\n\nThis object prints data unescaped within a <script> tag, wrapped in a ScriptTagProxy that guards against invalid script content.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.ScriptTagProxy","page":"Package Reference","title":"HypertextLiteral.ScriptTagProxy","text":"ScriptTagProxy(io)\n\nThis is a transparent proxy that ensures neither <!-- nor </script> occur in the output stream.\n\nExamples\n\njulia> gp = ScriptTagProxy(stdout);\njulia> print(gp, \"valid\");\nvalid\njulia> print(gp, \"</script>\")\nERROR: \"Content within a script tag must not contain `</script>`\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.StyleTag","page":"Package Reference","title":"HypertextLiteral.StyleTag","text":"StyleTag(data)\n\nThis object prints data unescaped within a <style> tag, wrapped in a StyleTagProxy that guards against invalid style content. Content is treated as if it had occurred within an attribute value, only that amperstand escaping is not used.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.StyleTagProxy","page":"Package Reference","title":"HypertextLiteral.StyleTagProxy","text":"StyleTagProxy(io)\n\nThis is a transparent proxy that ensures neither <!-- nor </style> occur in the output stream.\n\nExamples\n\njulia> gp = StyleTagProxy(stdout);\njulia> print(gp, \"valid\");\nvalid\njulia> print(gp, \"</style>\")\nERROR: \"Content within a style tag must not contain `</style>`\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.attribute_value-Tuple{String}","page":"Package Reference","title":"HypertextLiteral.attribute_value","text":"attribute_value(x)\n\nThis method may be implemented to specify a printed representation suitable for use within a quoted attribute value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.content-Tuple{Any}","page":"Package Reference","title":"HypertextLiteral.content","text":"content(x)\n\nThis method may be implemented to specify a printed representation suitable for text/html output. AbstractString, Symbol and Number (including Bool) types are printed, with proper escaping.\n\nA default implementation first looks to see if typeof(x) has implemented a way to show themselves as text/html, if so, this is used. Otherwise, the result is printed within a <span> tag, using a class that includes the module and type name. Hence, missing is serialized as: <span class=\"Base-Missing\">missing</span>.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.interpolate-Tuple{Any}","page":"Package Reference","title":"HypertextLiteral.interpolate","text":"interpolate(args)::Expr\n\nTake an interweaved set of Julia expressions and strings, tokenize the strings according to the HTML specification [1], wrapping the expressions with wrappers based upon the escaping context, and returning an expression that combines the result with an Result wrapper.\n\nFor these purposes, a Symbol is treated as an expression to be resolved; while a String is treated as a literal string that won't be escaped. Critically, interpolated strings to be escaped are represented as an Expr with head of :string.\n\nThere are tags, \"script\" and \"style\" which are rawtext, in these cases there is no escaping, and instead raise an exception if the appropriate ending tag is in substituted content.\n\n[1] https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.js-Tuple{Any}","page":"Package Reference","title":"HypertextLiteral.js","text":"js(x)\n\nThis method may be implemented to specify a printed representation suitable for use within a quoted attribute value starting with on.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.normalize_attribute_name-Tuple{Symbol}","page":"Package Reference","title":"HypertextLiteral.normalize_attribute_name","text":"normalize_attribute_name(name)\n\nFor String names, this simply verifies that they pass the attribute name production, but are otherwise untouched.\n\nFor Symbol names, this converts snake_case Symbol objects to their kebab-case equivalent. So that keywords, such as for could be used, we strip leading underscores.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.print_script-Tuple{IO, Any}","page":"Package Reference","title":"HypertextLiteral.print_script","text":"print_script(io, value)\n\nShow value as \"text/javascript\" to the given io, this provides some baseline functionality for built-in data types.\n\n- `nothing` becomes `undefined`\n- `missing` becomes `null`\n- `Bool` values are printed as `true` or `false`\n- `AbstractString` and `Symbol` become a double-quoted string\n- `AbstractVector` and `Tuple` become an array\n- `Dict` and `NamedTuple` become a Javascript object, with\n   keys converted to string values\n- `AbstractFloat` and `Integer` are printed directly, where\n  `NaN` remains `NaN` but `Inf` is printed as `Infinity`\n\nThe fallback behavior of print_script is to show the object as \"text/javascript\". The Javascript wrapper will take any string and let it be printed in this way.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.print_script_hook-Tuple{IO, Any}","page":"Package Reference","title":"HypertextLiteral.print_script_hook","text":"print_script_hook(io, value)\n\nProvides a hook to override print_script for custom Javascript runtimes, such as Pluto.jl, to provide their own value marshalling.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.print_value-Tuple{IO, Any}","page":"Package Reference","title":"HypertextLiteral.print_value","text":"print_value(io, value)\n\nThis is the default translation of interpolated values within rawtext tags, such as <style> and attribute values.\n\nThe elements of a Tuple or AbstractArray object are printed, with a space between each item.\nThe Pair, NamedTuple, and Dict objects are treated as if they are CSS style elements, with a colon between key and value, each pair delimited by a semi-colon.\nThe Nothing object is treated as an empty string.\n\nOtherwise, this method simply uses the standard print representation for the given object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.rewrite_inside_tag-Tuple{Any}","page":"Package Reference","title":"HypertextLiteral.rewrite_inside_tag","text":"rewrite_inside_tag(expr)\n\nAttempt to speed up serialization of inside_tag by exploring the expression tree at macro expansion time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.@htl-Tuple{Any}","page":"Package Reference","title":"HypertextLiteral.@htl","text":"@htl string-expression\n\nCreate a Result object with string interpolation ($) that uses context-sensitive hypertext escaping. Before Julia 1.6, interpolated string literals, e.g. $(\"Strunk & White\"), are treated as errors since they cannot be reliably detected (see Julia issue #38501).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#HypertextLiteral.@htl_str-Tuple{String}","page":"Package Reference","title":"HypertextLiteral.@htl_str","text":"@htl_str -> Result\n\nCreate a Result object with string interpolation ($) that uses context-sensitive hypertext escaping. Unlike the @htl macro, this string literal does not include escaping feature [1]. To include $ within user content one must write &#36;. Observe that &quot; and any other HTML ampersand escape sequence can be used as appropriate.\n\nIn this syntax, interpolation is extended beyond regular Julia strings to handle three additional cases: tuples, named tuples (for attributes), and generators. See Julia #38734 for the feature request so that this could also work within the @htl macro syntax.\n\n[1] There are also a few edge cases, see @raw_str documentation and Julia #22926 for more detail.\n\n\n\n\n\n","category":"macro"},{"location":"#HypertextLiteral-Overview","page":"Overview","title":"HypertextLiteral Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This package provides a Julia macro, @htl, that constructs an object which could be rendered to MIME\"text/html\" displays. This macro supports string interpolation sensible to the needs of HTML generation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using HypertextLiteral\n\nv = \"<1 Brown \\\"M&M's\\\"!\";\n\n@htl \"<span>$v</span>\"\n#-> <span>&lt;1 Brown &quot;M&amp;M&apos;s&quot;!</span>","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"An equivalent non-standard string literal, htl, is also provided.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"v = \"<1 Brown \\\"M&M's\\\"!\";\n\nhtl\"<span>$v</span>\"\n#-> <span>&lt;1 Brown &quot;M&amp;M&apos;s&quot;!</span>","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Interpolation can use the full expressive power of Julia.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"books = [\"Who Gets What & Why\", \"Switch\", \"Governing The Commons\"]\n\n@htl \"<ul>$(map(books) do b @htl(\"<li>$b\") end)</ul>\"\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"#Translation-Contexts","page":"Overview","title":"Translation Contexts","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"How a Julia expression is translated depends upon where it is used.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":" Native Julia Translation\nElement Content \"\\\"M&M\\\"'s\" M&amp;M&apos;s\n :name name\n [1, 2] or (1, 2) 12\n nothing omitted\n missing <span class=\"Base-Missing\">missing</span>\n (a = 1, b = 2) <span class=\"Core-NamedTuple\">(a = 1, b = 2)</span>\n Dict(:a => 1, :b => 2) <span class=\"Base-Dict\">Dict(:a => 1, :b => 2)</span>\nAttribute Value \"\\\"M&M\\\"'s\" M&amp;M&apos;s\n :name name\n [1, 2] or (1, 2) 1 2\n nothing omitted\n missing missing\n (a = 1, b = 2) a: 1; b: 2;\n Dict(:a => 1, :b => 2) a: 1; b: 2;\nScript Tag \"\\\"M&M\\\"'s\" \"\\\"M&M\\\"'s\"\n :name name\n [1, 2] or (1, 2) [1, 2]\n nothing undefined\n missing null\n Inf Infinity\n NaN NaN\n (a = 1, b = 2) {\"a\": 1, \"b\": 2}\n Dict(:a => 1, :b => 2) {\"a\": 1, \"b\": 2}","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If any of these translations are inconvenient:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"coalesce() can be used to provide an alternative for missing;\nsomething() provides a substitution for nothing;\nstring() will use the string translation instead; and\nHTML() can be used to bypass escaping within element content.","category":"page"},{"location":"#Table-of-Contents","page":"Overview","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Pages = [\"content.md\", \"attribute.md\", \"script.md\"]\nDepth = 3","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Pages = [\"design.md\", \"notation.md\", \"primitives.md\", \"reference.md\"]\nDepth = 1","category":"page"},{"location":"notation/#htl-String-Literal","page":"htl String Literal","title":"htl String Literal","text":"","category":"section"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"This package additionally provides the @htl_str non-standard string literal.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"using HypertextLiteral\n\nname = \"World\"\n\nhtl\"<span>Hello $name</span>\"\n#-> <span>Hello World</span>\n\n@htl_str \"<span>Hello \\$name</span>\"\n#-> <span>Hello World</span>","category":"page"},{"location":"notation/#Notable-Differences","page":"htl String Literal","title":"Notable Differences","text":"","category":"section"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Unlike @htl, the htl string literal uses @raw_str escaping rules. So long as a double-quote character does not come before a slash, the slash itself need not be escaped.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"<span>\\some\\path</span>\"\n#-> <span>\\some\\path</span>","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"In this notation, \\\" can be used to escape a double quote. However, other escape sequences are not expanded.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"Hello\\\"\\nWorld\\\"\"\n#-> Hello\"\\nWorld\"","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"As a special case, the dollar-sign ($) can be escaped by doubling.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"amount = 42\n\nhtl\"<span>They paid $$$amount</span>\"\n#-> <span>They paid $42</span>","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Alternatively, one can use the HTML character entity #&36;.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"<span>They paid &#36;$amount</span>\"\n#-> <span>They paid &#36;42</span>","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Unlike the @htl macro, nesting doesn't work.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"Hello $(htl\"World\")\"\n#-> ERROR: syntax: cannot juxtapose string literal","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Triple double-quoted syntax can be used in this case.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"\"\"Hello $(htl\"World\")\"\"\"\n#-> Hello World","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"However, this trick works only one level deep. Hence, there are some significant downsides to using this format, which are explored in detail at Julia #38948.","category":"page"},{"location":"notation/#Dynamic-Templates","page":"htl String Literal","title":"Dynamic Templates","text":"","category":"section"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"The @htl_str macro can be used to dynamically construct templates. Suppose you have a schema that is provided dynamically. Let's make a test database with exactly one row.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"T = NamedTuple{(:idx, :value), Tuple{Int64, String}};\n\ndatabase = [T((1, \"A&B\"))];\n\ndisplay(database)\n#=>\n1-element Vector{NamedTuple{(:idx, :value), …}:\n (idx = 1, value = \"A&B\")\n=#","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"We could construct a table header from this schema.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"fields = T.parameters[1]\n#-> (:idx, :value)\n\nhead = @htl \"<tr>$([@htl(\"<th>$x\") for x in fields])\"\n#-> <tr><th>idx<th>value","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Then, we need to compute a template for each row.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"row_template = \"<tr>$(join([\"<td>\\$(row[$(repr(x))])\" for x in fields]))\"\n\nprint(row_template)\n#-> <tr><td>$(row[:idx])<td>$(row[:value])","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Using eval with @htl_str we could construct our template function.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"eval(:(tablerow(row) = @htl_str $row_template))\n\ntablerow(database[1])\n#-> <tr><td>1<td>A&amp;B","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"A template for the entire table could be constructed.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"table_template = \"<table>$head\\$([tablerow(row) for row in data])</table>\"\n\nprint(table_template)\n#-> <table><tr><th>idx…$([tablerow(row) for row in data])</table>\n\neval(:(print_table(data) = @htl_str $table_template))","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Then, finally, this could be used.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"print_table(database)\n#-> <table><tr><th>idx<th>value<tr><td>1<td>A&amp;B</table>","category":"page"},{"location":"notation/#Regression-Tests-and-Notes","page":"htl String Literal","title":"Regression Tests & Notes","text":"","category":"section"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Due to @raw_str escaping, string literal forms are a bit quirky. Use the triple double-quoted form if your content has a double quote. Avoid slashes preceding a double quote, instead use the &#47; HTML entity.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"\\\"\\t\\\\\"\n#-> \"\\t\\\n\nhtl\"(\\\\\\\")\"\n#-> (\\\")","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Even though we could permit interpretation of arrays notation, we stick with keeping this an error for consistency with the macro form.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"$[1,2,3]\"\n#=>\nERROR: LoadError: DomainError with [1, 2, 3]:\ninterpolations must be symbols or parenthesized⋮\n=#","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Let's also not permit top-level assignments.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"$(k=value)\"\n#=>\nERROR: LoadError: DomainError with k = value:\nassignments are not permitted in an interpolation⋮\n=#","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Since the implementers of the notation have some control over the parsing, we can reliably detect string literals (Julia #38501).","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"\"\"<span>$(\"A&B\")</span>\"\"\"\n#-> <span>A&amp;B</span>","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"There is one less round of parenthesis needed for tuples, named tuples and generators (Julia #38734).","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"name = \"Hello\"\n\nhtl\"<tag $(user=name,)/>\"\n#-> <tag user='Hello'/>\n\nprint(htl\"<span>$(n for n in 1:3)</span>\")\n#-> <span>123</span>","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"Due to escaping rules, we interpret a dollar sign as beginning an expression, even if it might otherwise be preceded by a slash.","category":"page"},{"location":"notation/","page":"htl String Literal","title":"htl String Literal","text":"htl\"Hello\\$#\"\n#=>\nERROR: LoadError: \"missing expression at 7: #\"⋮\n=#","category":"page"}]
}

## Introduction

This package provides a Julia macro, `@htl`, that constructs an object
which could be rendered to `MIME"text/html"` displays. This macro
supports interpolation sensible to the needs of HTML generation.

    using HypertextLiteral

When printed directly to the console (via `show`), the output of this
macro reproduces the expression that generated them.

```julia
name = "World"

@htl("<span>Hello $name</span>")
#-> @htl "<span>Hello $(name)</span>"
```

When displayed to `"text/html"` or printed, the evaluation is shown.

    name = "World"

    display("text/html", @htl("<span>Hello $name</span>"))
    #-> <span>Hello World</span>

    print(@htl("<span>Hello $name</span>"))
    #-> <span>Hello World</span>

We use `NarrativeTest.jl` to ensure our examples are correct. After each
command is a comment with the expected output. To enhance readability,
we'll also use the following macro.

    macro print(expr)
        :(display("text/html", $expr))
    end

    @print @htl("<span>Hello World</span>")
    #-> <span>Hello World</span>

## Content Interpolation

Hypertext literal provides interpolation via `$`. Within content, the
ampersand (`&`), less-than (`<`), single-quote (`'`) and double-quote
(`"`) are escaped.

    book = "Strunk & White"

    @print @htl("<span>Today's Reading: $book</span>")
    #-> <span>Today's Reading: Strunk &amp; White</span>

To include `$` in the output, use `\$` as one would in a regular Julia
string. Other escape sequences, such as `\"` also work.

    @print @htl("They said, \"your total is \$42.50\".")
    #-> They said, "your total is $42.50".

Within tripled double-quotes, single double-quoted strings can go
unescaped, however, we still need to escape the dollar sign (`$`).

    @print @htl("""They said, "your total is \$42.50".""")
    #-> They said, "your total is $42.50".

Julia results can be interpolated using the `$(expr)` notation.
Strings, numeric values (including `Bool`) and symbols are supported.

    @print @htl("2+2 = $(2+2)")
    #-> 2+2 = 4

    @print @htl("<bool>$(false)</bool><sym>$(:sym)</sym>")
    #-> <bool>false</bool><sym>sym</sym>

Objects created by these macros are not further escaped, permitting us to
build reusable HTML templates.

    sq(x) = @htl("<span>$(x*x)</span>")

    @print @htl("<div>3^2 is $(sq(3))</div>")
    #-> <div>3^2 is <span>9</span></div>

Content generated by these macros can be nested. Within element content,
vectors and generators are automatically expanded, concatenating their
values.

    books = ["Who Gets What & Why", "Switch", "Governing The Commons"]

    @print @htl("<ul>$([@htl("<li>$b") for b in books])</ul>")
    #=>
    <ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>
    =#

    @print @htl("<ul>$((@htl("<li>$b") for b in books))</ul>")
    #=>
    <ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>
    =#

The `map(container) do item; … ;end` construct works and is performant.

    @print @htl("<ul>$(map(books) do b @htl("<li>$b") end)</ul>")
    #=>
    <ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>
    =#

## Attribute Interpolation

Interpolation within single and double quoted attribute values are
supported. Regardless of context, all four characters are escaped.

    qval = "\"&'"

    @print @htl("""<tag double="$qval" single='$qval' />""")
    #-> <tag double="&quot;&amp;&apos;" single='&quot;&amp;&apos;' />

Unquoted or bare attributes are also supported. These are serialized
using the single quoted style so that spaces and other characters do not
need to be escaped.

    arg = "book='Strunk & White'"

    @print @htl("<tag bare=$arg />")
    #-> <tag bare='book=&apos;Strunk &amp; White&apos;' />

Attributes may also be provided by any combination of dictionaries,
named tuples, and pairs. Attribute names are normalized, where
`snake_case` becomes `kebab-case`. We do not convert `camelCase` due to
XML (MathML and SVG) attribute case sensitivity. Moreover, `String`
attribute names are passed along as-is.

     attributes = Dict(:data_style => :green, "data_value" => 42, )

     @print @htl("<div $attributes/>")
     #-> <div data-style='green' data_value='42'/>

     @print @htl("<div $(:data_style=>:green) $(:dataValue=>42)/>")
     #-> <div data-style='green' dataValue='42'/>

     @print @htl("<div $((:data_style=>:green, "data_value"=>42))/>")
     #-> <div data-style='green' data_value='42'/>

     @print @htl("<div $((data_style=:green, dataValue=42))/>")
     #-> <div data-style='green' dataValue='42'/>

As you can see from this example, symbols and numbers (but not boolean
values) are automatically printed within attributes. This interpolation
works within quoted values as well.

    @print @htl("""<tag numeric="$(0)" symbol='$(:sym)'/>""")
    #-> <tag numeric="0" symbol='sym'/>

Within bare attributes, boolean values provide special support for
boolean HTML properties, such as `"disabled"`. When a bare value `false`
then the attribute is removed. When the value is `true` then the
attribute is kept, with value being an empty string (`''`).

    @print @htl("<button checked=$(true) disabled=$(false)>")
    #-> <button checked=''>

Since boolean values are given special treatment, they become an error
within quoted attribute values. At this time, this behavior is universal
and does not depend upon the exact attribute used.

    @print @htl("<button disabled='$(false)'>")
    #-> ERROR: "Boolean used within a quoted attribute."⋮

In HTML, many attributes specify values with space-delimited tokens,
such as the Cascading Style Sheet (CSS) `"class"` attribute. To support
these attributes, arrays and tuples produce space delimited output.

    @print @htl("<div class=$([:one, :two])/>")
    #-> <div class='one two'/>

    @print @htl("<div class=$((:one, :two))/>")
    #-> <div class='one two'/>

To support nested key/value structures, such as the CSS `"style"`
attribute, we have specialized expansion of dictionary like objects.
For each pair, keys are separated from their value with a colon `:`,
moreover, pairs are delimited by the semi-colon (`;`). Like attributes,
`snake_case` is converted to `kebab-case`.

    header_styles = Dict(:font_size => "25px", "padding-left" => "2em")

    @print @htl("<div style=$header_styles/>")
    #-> <div style='font-size: 25px; padding-left: 2em;'/>

    @print @htl("<div style=$((:font_size=>"25px","padding-left"=>"2em"))/>")
    #-> <div style='font-size: 25px; padding-left: 2em;'/>

    @print @htl("<div style=$((font_size="25px", padding_left="2em"))/>")
    #-> <div style='font-size: 25px; padding-left: 2em;'/>

These expansions work within quoted attributes.

    extra = Dict(:padding_left => "2em")

    @print @htl("<div style='font-size: 25px; $extra'/>")
    #-> <div style='font-size: 25px; padding-left: 2em;'/>

    @print @htl("<div style='font-size: 25px; $(:padding_left => "2em")'/>")
    #-> <div style='font-size: 25px; padding-left: 2em;'/>

## Script Interpolation

Within a `<script>` tag, Julia values are serialized to their equivalent
Javascript. String values are p

    sval = "Say \"Hello\"!";

    @print @htl("<script>var x = $sval; alert(x); </script>")
    #-> <script>var x = "Say \"Hello\"!"; alert(x); </script>

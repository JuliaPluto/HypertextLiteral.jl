# HypertextLiteral.jl

This package provides a Julia string literal, `htl`, and equivalent
macro, `@htl`, that construct an object that could be rendered to
`MIME"text/html"` displays. These macros support interpolation sensible
to the needs of HTML generation.

    using HypertextLiteral

When printed directly to the console (via `show`), the output of these
macros reproduce a verified expression that generated them.

```julia
name = "World"

htl"<span>Hello $name</span>"
#-> htl"<span>Hello $name</span>"

@htl("<span>Hello $name</span>")
#-> @htl "<span>Hello $(name)</span>"
```

When displayed to `"text/html"` the evaluation is shown.

    name = "World"

    display("text/html", htl"<span>Hello $name</span>")
    #-> <span>Hello World</span>

    display("text/html", @htl("<span>Hello $name</span>"))
    #-> <span>Hello World</span>

We use `NarrativeTest.jl` to ensure our examples are correct. After each
command is a comment with the expected output. To enhance readability,
we'll also use the following macro.

    macro print(expr)
        :(display("text/html", $expr))
    end

    @print htl"<span>Hello World</span>"
    #-> <span>Hello World</span>

    @print @htl("<span>Hello World</span>")
    #-> <span>Hello World</span>

Throughout this tutorial, we'll mostly stick with the macro form since
it has better syntax highlighting support, however, the string literal
form works (almost) equivalently (and is a tad shorter).

## Content Interpolation

Hypertext literal provides interpolation via `$`. Within content, the
ampersand (`&`), less-than (`<`), single-quote (`'`) and double-quote
(`"`) are escaped.

    book = "Strunk & White"

    @print @htl("<span>Today's Reading: $book</span>")
    #-> <span>Today's Reading: Strunk &amp; White</span>

To include a literal `$` in the output, use `\$` as one would in a
regular Julia string. Other escape sequences, such as `\"` also work.

    @print @htl("They said, \"your total is \$42.50\".")
    #-> They said, "your total is $42.50".

Within triple quotes, single quoted strings can go unescaped, however,
we still need to escape the dollar sign (`$`).

    @print @htl("""They said, "your total is \$42.50".""")
    #-> They said, "your total is $42.50".

Julia results can be interpolated using the `$(expr)` notation.
Strings, numeric values (including `Bool`) and symbols are supported.

    @print @htl("2+2 = $(2+2)")
    #-> 2+2 = 4

    @print @htl("<bool>$(false)</bool><sym>$(:sym)</sym>")
    #-> <bool>false</bool><sym>sym</sym>

Functions returning objects created by this macro are not further
escaped, permitting us to build reusable HTML templates.

    sq(x) = @htl("<span>$(x*x)</span>")

    @print @htl("<div>3^2 is $(sq(3))</div>")
    #-> <div>3^2 is <span>9</span></div>

Content generated by these macros can be nested. Within element content,
vectors are automatically expanded. By default, arrays and tuples are
enumerated, printing each of their values.

    books = ["Who Gets What & Why", "Switch", "Governing The Commons"]

    @print @htl("<ul>$([@htl("<li>$b") for b in books])</ul>")
    #=>
    <ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>
    =#

    @print @htl("<ul>$(map(books) do b @htl("<li>$b") end)</ul>")
    #=>
    <ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>
    =#

## Attribute Interpolation

Interpolation within single and double quoted attribute values are
supported. Regardless of context, all four characters are escaped.

    qval = "\"&'"

    @print @htl("""<tag double="$qval" single='$qval' />""")
    #-> <tag double="&quot;&amp;&apos;" single='&quot;&amp;&apos;' />

Unquoted or bare attributes are also supported. These are serialized
using the single quoted style so that spaces and other characters do not
need to be escaped.

    arg = "book='Strunk & White'"

    @print @htl("<tag bare=$arg />")
    #-> <tag bare='book=&apos;Strunk &amp; White&apos;' />

Attributes may also be provided by any combination of dictionaries,
named tuples, and pairs. Attribute names are normalized, where
`snake_case` becomes `kebab-case`. We do not convert `camelCase` due to
XML (MathML and SVG) attribute case sensitivity. Moreover, `String`
attribute names are passed along as-is.

     attributes = Dict(:data_style => :green, "data_value" => 42, )

     @print @htl("<div $attributes/>")
     #-> <div data-style='green' data_value='42'/>

     @print @htl("<div $(:data_style=>:green) $(:dataValue=>42)/>")
     #-> <div data-style='green' dataValue='42'/>

     @print @htl("<div $((:data_style=>:green, "data_value"=>42))/>")
     #-> <div data-style='green' data_value='42'/>

     @print @htl("<div $((data_style=:green, dataValue=42))/>")
     #-> <div data-style='green' dataValue='42'/>

As you can see from this example, symbols and numbers (but not boolean
values) are automatically printed within attributes. This interpolation
works within quoted values as well.

    @print @htl("""<tag numeric="$(0)" symbol='$(:sym)'/>""")
    #-> <tag numeric="0" symbol='sym'/>

Within bare attributes, boolean values provide special support for
boolean HTML properties, such as `"disabled"`. When a bare value `false`
then the attribute is removed. When the value is `true` then the
attribute is kept, with value being an empty string (`''`).

    @print @htl("<button checked=$(true) disabled=$(false)>")
    #-> <button checked=''>

Since boolean values are given special treatment, they become an error
within quoted attribute values. At this time, this behavior is universal
and does not depend upon the exact attribute used.

    @print @htl("<button disabled='$(false)'>")
    #-> ERROR: "Boolean used within a quoted attribute."⋮

In HTML, many attributes specify values with space-delimited tokens,
such as the Cascading Style Sheet (CSS) `"class"` attribute. To support
these attributes, arrays and tuples produce space delimited output.

    @print @htl("<div class=$([:one, :two])/>")
    #-> <div class='one two'/>

    @print htl"<div class=$(:one, :two)/>"
    #-> <div class='one two'/>

To support nested key/value structures, such as the CSS `"style"`
attribute, we have specialized expansion of dictionary like objects.
For each pair, keys are separated from their value with a colon `:`,
moreover, pairs are delimited by the semi-colon (`;`). Like attributes,
`snake_case` is converted to `kebab-case`.

    header_styles = Dict(:font_size => "25px", "padding-left" => "2em")

    @print @htl("<div style=$header_styles/>")
    #-> <div style='font-size: 25px; padding-left: 2em;'/>

    @print @htl("<div style=$((:font_size=>"25px","padding-left"=>"2em"))/>")
    #-> <div style='font-size: 25px; padding-left: 2em;'/>

    @print @htl("<div style=$((font_size="25px", padding_left="2em"))/>")
    #-> <div style='font-size: 25px; padding-left: 2em;'/>

## Integration & Extension

For hypertext content, Julia has a protocol to let independent libraries
work together. For any object, one could ask if it is `showable` to
displays supporting the `"text/html"` mimetype.

    showable("text/html", @htl("<tag/>"))
    #-> true

We use this protocol to integrate with third party tools, such as
`Hyperscript` without introducing dependencies.

    using Hyperscript
    @tags span div

    @print component = span("...")
    #-> <span>...</span>

Since `component` is showable via `"text/html"`, it can be integrated
directly. Conversely, results of `@htl` interpolation can be included
directly as a Hyperscript node.

    @print @htl("<div>$(span("..."))</div>")
    #-> <div><span>...</span></div>

    @print div(@htl("<span>...</span>"))
    #-> <div><span>...</span></div>

Unfortunately, there is no such protocol for attribute values, which
have different escaping needs (single or double quote, respectively).
Hence, integrating `Hyperscript`'s CSS `Unit` object, such as `2em`,
isn't automatic. By default, a `MethodError` is raised.

    typeof(2em)
    #-> Hyperscript.Unit{:em, Int64}

    @print @htl("<div style=$((border=2em,))>...</div>")
    #-> …ERROR: MethodError: no method matching attribute(…Unit{:em,⋮

Letting objects of an unknown type work with `@htl` macros follows
Julia's sensibilities, you implement `attribute` for that type.

    HypertextLiteral.attribute(x::Hyperscript.Unit) = x

    @print @htl("<div style=$((border=2em,))>...</div>")
    #-> <div style='border: 2em;'>...</div>

This works as follows. When `obj` is encountered in an attribute
context, `attribute(obj)` is called. Then, `print()` is called on the
result to create a character stream. This stream is then escaped and
included into the results. Let's do this with a `Custom` object.

    struct Custom data::String end

    HypertextLiteral.attribute(x::Custom) = x.data

    @print @htl("<tag attribute=$(Custom("'A&B'"))/>")
    #-> <tag attribute='&apos;A&amp;B&apos;'/>

There is a corresponding `content()` function used when an object is
encountered within element content. Therefore, we could provide a
representation there as well.

    HypertextLiteral.content(x::Custom) = "<span>$(x.data)</span>"

    @print @htl("<div>$(Custom("Hello World"))</div>")
    #-> <div>&lt;span>Hello World&lt;/span></div>

If one knows that the resulting data is *always* properly escaped, one
can use Julia's `HTML` wrapper to signal this property.

    HypertextLiteral.content(x::Custom) = HTML("<span>$(x.data)</span>")

    @print @htl("<div>$(Custom("Hello World"))</div>")
    #-> <div><span>Hello World</span></div>

However, in this case, it's more robust to construct the `"text/html"`
representation for the object using Julia's showable protocol.

    struct MoreCustom data::String end

    function Base.show(io::IO, mime::MIME"text/html", c::MoreCustom)
        value = replace(replace(c.data, "&"=>"&amp;"), "<"=>"&lt;")
        print(io, "<custom>$(value)</custom>")
    end

    @print @htl("<span>$(MoreCustom("a&b"))</span>")
    #-> <span><custom>a&amp;b</custom></span>

There is additionally an `attributes` function which can be used
to handle objects inside an element's tag. For more detail, please see
the design section of this documentation.

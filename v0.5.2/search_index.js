var documenterSearchIndex = {"docs":
[{"location":"extend/#Integration","page":"Extend","title":"Integration","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"For hypertext content, Julia has a protocol to let independent libraries work together. For any object, one could ask if it is showable to displays supporting the \"text/html\" mimetype.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using HypertextLiteral\n\nmacro print(expr)\n    :(display(\"text/html\", $expr))\nend\n\nshowable(\"text/html\", @htl(\"<tag/>\"))\n#-> true","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"We use this protocol to integrate with third party tools, such as Hyperscript without introducing dependencies.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using Hyperscript\n@tags span div\n\n@print component = span(\"...\")\n#-> <span>...</span>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Since component is showable via \"text/html\", it can be integrated directly. Conversely, results of @htl interpolation can be included directly as a Hyperscript node.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"@print @htl(\"<div>$(span(\"...\"))</div>\")\n#-> <div><span>...</span></div>\n\n@print div(@htl(\"<span>...</span>\"))\n#-> <div><span>...</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Generally, any custom component can be enhanced to work directly with this and similar libraries by implementing show for \"text/html\". In this case, properly escaping content is important.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Custom data::String end\n\nfunction Base.show(io::IO, mime::MIME\"text/html\", c::Custom)\n    value = replace(replace(c.data, \"&\"=>\"&amp;\"), \"<\"=>\"&lt;\")\n    print(io, \"<custom>$(value)</custom>\")\nend\n\n@print @htl(\"<span>$(Custom(\"a&b\"))</span>\")\n#-> <span><custom>a&amp;b</custom></span>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Conservatively, many more characters should be escaped, including both single (') and double (\") quotes.","category":"page"},{"location":"extend/#Content-Extensions","page":"Extend","title":"Content Extensions","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"Sometimes it's useful to extend @htl so that it knows how to print your object without implementing show for \"text/html\" this can be done by implementing a method for the content() function.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Custom data::String end\n\nHypertextLiteral.content(c::Custom) = \"They said: '$(c.data)'\"\n\n@print @htl(\"<span>$(Custom(\"Hello\"))</span>\")\n#-> <span>They said: &apos;Hello&apos;</span>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"By default, the result of the content() is fully escaped, in this way you don't have to worry about implement one's own escaping. If your custom object is building tagged content, you can bypass escaping.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"HypertextLiteral.content(c::Custom) =\n    HypertextLiteral.Bypass(\"<span>$(c.data)</span>\")\n\n@print @htl(\"<div>$(Custom(\"Hello\"))</div>\")\n#-> <div><span>Hello</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Unfortunately, this won't encode the argument to your object.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"@print @htl(\"<div>$(Custom(\"<script>alert('whoops!);\"))</div>\")\n#-> <div><span><script>alert('whoops!);</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"This can be addressed with Reprint. In this case, the value you return is a functor (and object holding a function) built by Reprint.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using HypertextLiteral: Bypass, Reprint\n\nHypertextLiteral.content(c::Custom) =\n    Reprint(io::IO -> begin\n        print(io, Bypass(\"<span>\"))\n        print(io, c.data)\n        print(io, Bypass(\"</span>\"))\n    end)\n\n@print @htl(\"<div>$(Custom(\"a&b\"))</div>\")\n#-> <div><span>a&amp;b</span></div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"This is essentially what @htl macro produces.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"HypertextLiteral.content(c::Custom) =\n    @htl(\"<span>$(c.data)</span>\")\n\n@print @htl(\"<div>$(Custom(\"a&b\"))</div>\")\n#-> <div><span>a&amp;b</span></div>","category":"page"},{"location":"extend/#Attribute-Value-Context","page":"Extend","title":"Attribute Value Context","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"Unlike content which has a show \"text/html\" fallback, there is no such protocol for attribute values, which have different escaping needs (single or double quote, respectively). Hence, integrating Hyperscript's CSS Unit object, such as 2em, isn't automatic. By default, a MethodError is raised.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"typeof(2em)\n#-> Hyperscript.Unit{:em, Int64}\n\n@print @htl(\"<div style=$((border=2em,))>...</div>\")\n#-> …ERROR: MethodError: no method matching attribute_value(…Unit{:em,⋮","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Letting objects of an unknown type work with @htl macros follows Julia's sensibilities, you implement attribute_value for that type.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"HypertextLiteral.attribute_value(x::Hyperscript.Unit) = x\n\n@print @htl(\"<div style=$((border=2em,))>...</div>\")\n#-> <div style='border: 2em;'>...</div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"This works as follows. When obj is encountered in an attribute context, attribute_value(obj) is called. Then, print() is called on the result to create a character stream. This stream is then escaped and included into the results. Let's do this with a Custom object.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"struct Custom data::String end\n\nHypertextLiteral.attribute_value(x::Custom) = x.data\n\n@print @htl(\"<tag attribute=$(Custom(\"'A&B'\"))/>\")\n#-> <tag attribute='&apos;A&amp;B&apos;'/>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"Like content above, Bypass and Reprint work identically.","category":"page"},{"location":"extend/#Inside-Tag-Context","page":"Extend","title":"Inside Tag Context","text":"","category":"section"},{"location":"extend/","page":"Extend","title":"Extend","text":"In some important cases one wishes to expand a Julia object into a set of attributes. This can be done by implementing insidetag(). At this point, it's better to study the implementation in convert.jl. Here is an example.","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"using HypertextLiteral: attribute_pair\n\nstruct CustomCSS class::Vector{Symbol}; style end\n\nHypertextLiteral.inside_tag(s::CustomCSS) = begin\n    myclass = join((string(x) for x in s.class), \" \")\n    Reprint() do io::IO\n        print(io, attribute_pair(:class, myclass))\n        print(io, attribute_pair(:style, s.style))\n    end\nend\n\nstyle = CustomCSS([:one, :two], :background_color => \"#92a8d1\")\n\n@print @htl(\"<div $style>Hello</div>\")\n#-> <div class='one two' style='background-color: #92a8d1;'>Hello</div>","category":"page"},{"location":"extend/","page":"Extend","title":"Extend","text":"There is a small ecosystem of methods to implement the expansion of Dict, Pair, NamedTuple, Vector, Tuple and Base.Generator in multiple contexts. They could be reused or just ignored.","category":"page"},{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"This package is implemented according to several design criteria.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Operation of interpolated expressions ($) should (mostly) mirror what they would do with regular Julia strings, updated with hypertext escaping sensibilities including proper escaping.\nSpeed of construction is critically important. This library is intended to be used deep within systems that generate extensive number of very large reports, interactively or in batch.\nWith exception of boolean attributes (which must be removed to be false), input is treated as-is and not otherwise modified.\nProvide reasonable interpretation for Dict, Vector and other objects as element content, attributes, and attribute values; to ensure the library is predictable, these interpretations should not depend upon namespace, element name, or the attribute name.\nSince the style and class attributes are so important in HTML construction, universal interpretations of Julia constructs should make sense to aid these CSS attributes.\nThere should be a discoverable and well documented extension API that permits custom data types to provide their own serialization strategies based upon syntactical context.\nBy default, use of unknown objects is an error. However, it should be trivial to permit their usage via Julia method implementation.\nAs much processing (e.g. hypertext lexical analysis) should be done during macro expansion to reduce runtime and to report errors early. We'll be slightly slower on interactive use to be fast in batch.\nFull coverage of HTML syntax or reporting syntax or semantic errors within the HTML content is not a goal.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"To discuss the design in more depth, let's restart our environment.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using HypertextLiteral\n\nmacro print(expr)\n    :(display(\"text/html\", $expr))\nend","category":"page"},{"location":"design/#Specific-Design-Decisions","page":"Design","title":"Specific Design Decisions","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Objects created by @htl are lazily constructed. What do we show on the REPL? We decided to parrot back the macro expression.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"Hello World\"\n\"Hello World\"\n\n@htl(\"<span>$x</span>\")\n#-> @htl \"<span>$(x)</span>\"","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"You could use the print command to evaluate the expression, showing the \"text/html\" results.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"Hello World\"\n\"Hello World\"\n\nprint(@htl(\"<span>$x</span>\"))\n#-> <span>Hello World</span>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"So that the scope of objects serialized in this manner is clear, we don't permit adjacent unquoted values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"<tag bare=$(true)$(:invalid)\")\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"While assignment operator is permitted in Julia string interpolation, we exclude it to guard it against accidently forgetting a comma.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<div $((data_value=42,))/>\")\n#-> <div data-value='42'/>\n\n@htl(\"<div $((data_value=42))/>\")\n#=>\nERROR: LoadError: DomainError with data_value = 42:\nassignments are not permitted in an interpolation⋮\n=#\n\n@htl(\"<div $(data_value=42)/>\")\n#=>\nERROR: LoadError: DomainError with data_value = 42:\nassignments are not permitted in an interpolation⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Symbols and Numeric values are properly escaped. While it is perhaps faster to assume all Symbol and Number objects could never contain invalid characters, we don't make this assumption.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"\"\"<tag att=$(Symbol(\"'&\"))>$(Symbol(\"<&\"))</tag>\"\"\")\n#-> <tag att='&apos;&amp;'>&lt;&amp;</tag>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Julia's regular interpolation stringifies everything. We don't do that we treat a Vector as a sequence to be concatenated. Moreover, we let the interpretation be customized though an extensive API.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"$([x for x in 1:3])\"\n#-> 123","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Since Julia's regular string interpolation works with the splat operator, we implement this as well, by concatenating results.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"$([x for x in 1:3]...)\"\n#-> 123","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Observe that map() is currently the most performant way to loop.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"$(map(1:3) do x; x; end)\"\n#-> 123","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The script and style tags use a \"raw text\" encoding where all content up-to the end tag is not escaped using ampersands.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"book = \"Strunk & White\"\n@print @htl(\"\"\"<script>var book = \"$book\"</script>\"\"\")\n#-> <script>var book = \"Strunk & White\"</script>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We throw an error if the end tag is accidently included. It is possible to improve the public API to let this be customized.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"bad = \"</style>\"\n\n@htl(\"\"\"<style>$bad</style>\"\"\")\n#=>\nERROR: DomainError with \"</style>\":\n  Content of <style> cannot contain the end tag (`</style>`).\n=#","category":"page"},{"location":"design/#Detection-of-String-Literals","page":"Design","title":"Detection of String Literals","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Before v1.6, we cannot reliably detect string literals using the @htl macro, so they are errors (when we can detect them).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"#? VERSION < v\"1.6.0-DEV\"\n@print @htl \"Look, Ma, $(\"<i>automatic escaping</i>\")!\"\n#-> ERROR: LoadError: \"interpolated string literals are not supported\"⋮","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"However, you can fix by wrapping a value in a string function.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl \"Look, Ma, $(string(\"<i>automatic escaping</i>\"))!\"\n#-> Look, Ma, &lt;i>automatic escaping&lt;/i>!","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"In particular, there are edge cases where unescaped string literal content can leak.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"\"\n\n#? VERSION < v\"1.6.0-DEV\"\n@print @htl(\"$x$(\"<script>alert(\\\"Hello\\\")</script>\")\")\n#-> <script>alert(\"Hello\")</script>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Julia #38501 was fixed in v1.6.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"#? VERSION >= v\"1.6.0-DEV\"\n@print @htl \"<tag>$(\"escape&me\")</tag>\"\n#-> <tag>escape&amp;me</tag>","category":"page"},{"location":"design/#Regression-Tests","page":"Design","title":"Regression Tests","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Escaped strings are handled by @htl as one might expect.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"\\\"\\t\\\\\")\n#-> \"\t\\\n\n@print @htl(\"(\\\\\\\")\")\n#-> (\\\")","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Attribute names should be non-empty and not in a list of excluded characters.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag $(\"\" => \"value\")/>\")\n#-> ERROR: LoadError: \"Attribute name must not be empty.\"⋮\n\n@print @htl(\"<tag $(\"&att\" => \"value\")/>\")\n#=>\nERROR: LoadError: DomainError with &att:\nInvalid character ('&') found within an attribute name.⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Unquoted interpolation adjacent to a raw string is also an error.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"<tag bare=literal$(:invalid)\")\n#=>\nERROR: LoadError: DomainError with :invalid:\nUnquoted attribute interpolation is limited to a single component⋮\n=#\n\n@htl(\"<tag bare=$(invalid)literal\")\n#=>\nERROR: LoadError: DomainError with bare=literal:\nUnquoted attribute interpolation is limited to a single component⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"String interpolation is limited to symbols or parenthesized expressions. For more details on this see Julia #37817.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@htl(\"$[1,2,3]\")\n#=>\nERROR: syntax: invalid interpolation syntax: \"$[\"⋮\n=#","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Literal content can contain Unicode values.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"Hello\"\n\n@print @htl(\"⁅$(x)⁆\")\n#-> ⁅Hello⁆","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Escaped content may also contain Unicode.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"x = \"⁅Hello⁆\"\n\n@print @htl(\"<tag>$x</tag>\")\n#-> <tag>⁅Hello⁆</tag>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Ensure that dictionary style objects are serialized. See issue #7.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"let\n    h = @htl(\"<div style=$(Dict(\"color\" => \"red\"))>asdf</div>\")\n    repr(MIME\"text/html\"(), h)\nend\n#-> \"<div style='color: red;'>asdf</div>\"","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Let's ensure that attribute values in a dictionary are escaped.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"@print @htl(\"<tag escaped=$(Dict(:esc=>\"'&\\\"<\"))/>\")\n#-> <tag escaped='esc: &apos;&amp;&quot;&lt;;'/>","category":"page"},{"location":"primitives/#Utility-Classes","page":"Primitives","title":"Utility Classes","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This is a regression test for components upon which HTL is constructed, the design centers around EscapeProxy which escapes content printed to it. There are several wrappers which drive special proxy handling.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"using HypertextLiteral: EscapeProxy, Bypass, Reprint, Render","category":"page"},{"location":"primitives/#EscapeProxy","page":"Primitives","title":"EscapeProxy","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This utility class acts wraps an IO stream to provide HTML escaping.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"io = IOBuffer()\nep = EscapeProxy(io)\n\nmacro echo(expr)\n    :($expr; print(String(take!(io))))\nend","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"The result of this proxy is that regular content printed to it is passed along to the wrapped IO, after escaping the ampersand (&), less-than (<), single-quote ('), and double-quote (\").","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"@echo print(ep, \"(&'<\\\")\")\n#-> (&amp;&apos;&lt;&quot;)","category":"page"},{"location":"primitives/#Bypass","page":"Primitives","title":"Bypass","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This wrapper simply prints its content.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"print(Bypass(\"<tagged/>\"))\n#-> <tagged/>","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Printed content wrapped with Bypass is not subject to escaping.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"@echo print(ep, Bypass(\"<span>\"), \"<A&B>\", Bypass(\"</span>\"))\n#-> <span>&lt;A&amp;B></span>","category":"page"},{"location":"primitives/#Reprint","page":"Primitives","title":"Reprint","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This wrapper holds a closure that prints to an io.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"print(Reprint(io::IO -> print(io, \"Hello World\")))\n#-> Hello World","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"Reprinted content is still subject to escaping.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"@echo print(ep, Reprint(io -> print(io, \"(&'<\\\")\")))\n#-> (&amp;&apos;&lt;&quot;)","category":"page"},{"location":"primitives/#Render","page":"Primitives","title":"Render","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"This wrapper prints text/html display of an object.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"struct Custom\n    content\nend\n\nBase.show(io::IO, m::MIME\"text/html\", c::Custom) =\n   print(io, c.content)\n\nprint(Render(Custom(\"<tag/>\")))\n#-> <tag/>","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"The printed content is not subject to escaping.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"@echo print(ep, Render(Custom(\"<tag/>\")))\n#-> <tag/>","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"It's an error if the wrapped object isn't showable to \"text/html\".","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"print(Render(\"This is an error!\"))\n#-> ERROR: MethodError: … show(… ::MIME{Symbol(\"text/html\")}⋮","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [HypertextLiteral]\nPrivate = true","category":"page"},{"location":"reference/#HypertextLiteral.HypertextLiteral","page":"Reference","title":"HypertextLiteral.HypertextLiteral","text":"HypertextLiteral\n\nThis library provides a @htl() macro which implements interopolation that is aware of hypertext escape context.\n\n\n\n\n\n","category":"module"},{"location":"reference/#HypertextLiteral.EscapeProxy","page":"Reference","title":"HypertextLiteral.EscapeProxy","text":"EscapeProxy(io) - wrap an `io` to perform HTML escaping\n\nThis is a transparent proxy that performs HTML escaping so that objects that are printed are properly converted into valid HTML values. As a special case, objects wrapped with Bypass are not escaped, and bypass the proxy.\n\nExamples\n\njulia> ep = EscapeProxy(stdout);\njulia> print(ep, \"A&B\")\nA&amp;B\njulia> print(ep, Bypass(\"<tag/>\"))\n<tag/>\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Render","page":"Reference","title":"HypertextLiteral.Render","text":"Render(data) - printed object shows its text/html\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Reprint","page":"Reference","title":"HypertextLiteral.Reprint","text":"Reprint(fn) -- apply the lambda function when printed\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.Result","page":"Reference","title":"HypertextLiteral.Result","text":"Result(expr, unwrap)\n\nAddress display modalities by showing the macro expression that generated the results when shown on the REPL. However, when used with print() show the results. This object is also showable to any IO stream via \"text/html\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#HypertextLiteral.attribute_value-Tuple{AbstractString}","page":"Reference","title":"HypertextLiteral.attribute_value","text":"attribute_value(x)\n\nThis method may be implemented to specify a printed representation suitable for use within a quoted attribute value. By default, the print representation of an object is used, and then propertly escaped. There are a few overrides that we provide.\n\nThe elements of a Tuple or AbstractArray object are printed, with a space between each item.\nThe Pair, NamedTuple, and Dict objects are treated as if they are CSS style elements, with a colon between key and value, each pair delimited by a semi-colon.\nThe Bool object, which has special treatment for bare inside_tag, is an error when used within a quoted attribute.\n\nIf an object is wrapped with HTML then it is included in the quoted attribute value as-is, without inspection or escaping.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.content-Tuple{Any}","page":"Reference","title":"HypertextLiteral.content","text":"content(x)\n\nThis method may be implemented to specify a printed representation suitable for text/html output. As a special case, if the result is wrapped with HTML, then it is passed along as-is. Otherwise, the print representation of the resulting value is escaped. By default AbstractString, Number and Symbol values are printed and escaped. The elements of Tuple and AbstractArray are concatinated and then escaped. If a method is not implemented for a given object, then we attempt to show it via MIME\"text/html\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.inside_tag-Tuple{Pair}","page":"Reference","title":"HypertextLiteral.inside_tag","text":"inside_tag(value)\n\nConvert Julian object into a serialization of attribute pairs, showable via MIME\"text/html\". The default implementation of this delegates value construction of each pair to attribute_pair().\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.interpolate-Tuple{Any,Any}","page":"Reference","title":"HypertextLiteral.interpolate","text":"interpolate(args, this)::Expr\n\nTake an interweaved set of Julia expressions and strings, tokenize the strings according to the HTML specification [1], wrapping the expressions with wrappers based upon the escaping context, and returning an expression that combines the result with an Result wrapper.\n\nFor these purposes, a Symbol is treated as an expression to be resolved; while a String is treated as a literal string that won't be escaped. Critically, interpolated strings to be escaped are represented as an Expr with head of :string.\n\nThere are tags, \"script\" and \"style\" which are rawtext, in these cases there is no escaping, and instead raise an exception if the appropriate ending tag is in substituted content.\n\n[1] https://html.spec.whatwg.org/multipage/parsing.html#tokenization\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.normalize_attribute_name-Tuple{Symbol}","page":"Reference","title":"HypertextLiteral.normalize_attribute_name","text":"normalize_attribute_name(name)::String\n\nFor String names, this simply verifies that they pass the attribute name production, but are otherwise untouched.\n\nFor Symbol names, this converts snake_case Symbol objects to their kebab-case equivalent. So that keywords, such as for could be used, we strip leading underscores.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.rawtext-Tuple{Symbol,AbstractString}","page":"Reference","title":"HypertextLiteral.rawtext","text":"rawtext(context, value)\n\nWrap a string value that occurs with RAWTEXT, SCRIPT and other element context so that it is showable(\"text/html\"). The default implementation ensures that the given value doesn't contain substrings illegal for the given context.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.rewrite_inside_tag-Tuple{Any}","page":"Reference","title":"HypertextLiteral.rewrite_inside_tag","text":"rewrite_inside_tag(expr)\n\nAttempt to speed up serialization of inside_tag by exploring the expression tree at macro expansion time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HypertextLiteral.@htl-Tuple{Any}","page":"Reference","title":"HypertextLiteral.@htl","text":"@htl string-expression\n\nCreate a Result object with string interpolation ($) that uses context-sensitive hypertext escaping. Before Julia 1.6, interpolated string literals, e.g. $(\"Strunk & White\"), are treated as errors since they cannot be reliably detected (see Julia issue #38501).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#HypertextLiteral.@htl_str-Tuple{String}","page":"Reference","title":"HypertextLiteral.@htl_str","text":"@htl_str -> Result\n\nCreate a Result object with string interpolation ($) that uses context-sensitive hypertext escaping. Unlike the @htl macro, this string literal does not include escaping feature [1]. To include $ within user content one must write &#36;. Observe that &quot; and any other HTML ampersand escape sequence can be used as appropriate.\n\nIn this syntax, interpolation is extended beyond regular Julia strings to handle three additional cases: tuples, named tuples (for attributes), and generators. See Julia #38734 for the feature request so that this could also work within the @htl macro syntax.\n\n[1] There are also a few edge cases, see @raw_str documentation and Julia #22926 for more detail. See Julia #38948 for a feature request that would provide a paired unicode syntax.\n\n\n\n\n\n","category":"macro"},{"location":"#Introduction","page":"Usage","title":"Introduction","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"This package provides a Julia macro, @htl, that constructs an object which could be rendered to MIME\"text/html\" displays. This macro support interpolation sensible to the needs of HTML generation.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"using HypertextLiteral","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"When printed directly to the console (via show), the output of this macro reproduce a verified expression that generated them.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"name = \"World\"\n\n@htl(\"<span>Hello $name</span>\")\n#-> @htl \"<span>Hello $(name)</span>\"","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"When displayed to \"text/html\" or printed, the evaluation is shown.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"name = \"World\"\n\ndisplay(\"text/html\", @htl(\"<span>Hello $name</span>\"))\n#-> <span>Hello World</span>\n\nprint(@htl(\"<span>Hello $name</span>\"))\n#-> <span>Hello World</span>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"We use NarrativeTest.jl to ensure our examples are correct. After each command is a comment with the expected output. To enhance readability, we'll also use the following macro.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"macro print(expr)\n    :(display(\"text/html\", $expr))\nend\n\n@print @htl(\"<span>Hello World</span>\")\n#-> <span>Hello World</span>","category":"page"},{"location":"#Content-Interpolation","page":"Usage","title":"Content Interpolation","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"Hypertext literal provides interpolation via $. Within content, the ampersand (&), less-than (<), single-quote (') and double-quote (\") are escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"book = \"Strunk & White\"\n\n@print @htl(\"<span>Today's Reading: $book</span>\")\n#-> <span>Today's Reading: Strunk &amp; White</span>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"To include $ in the output, use \\$ as one would in a regular Julia string. Other escape sequences, such as \\\" also work.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"They said, \\\"your total is \\$42.50\\\".\")\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Within tripled double-quotes, single double-quoted strings can go unescaped, however, we still need to escape the dollar sign ($).","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"\"\"They said, \"your total is \\$42.50\".\"\"\")\n#-> They said, \"your total is $42.50\".","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Julia results can be interpolated using the $(expr) notation. Strings, numeric values (including Bool) and symbols are supported.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"2+2 = $(2+2)\")\n#-> 2+2 = 4\n\n@print @htl(\"<bool>$(false)</bool><sym>$(:sym)</sym>\")\n#-> <bool>false</bool><sym>sym</sym>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Objects created by these macros are not further escaped, permitting us to build reusable HTML templates.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"sq(x) = @htl(\"<span>$(x*x)</span>\")\n\n@print @htl(\"<div>3^2 is $(sq(3))</div>\")\n#-> <div>3^2 is <span>9</span></div>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Content generated by these macros can be nested. Within element content, vectors and generators are automatically expanded, concatenating their values.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"books = [\"Who Gets What & Why\", \"Switch\", \"Governing The Commons\"]\n\n@print @htl(\"<ul>$([@htl(\"<li>$b\") for b in books])</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#\n\n@print @htl(\"<ul>$((@htl(\"<li>$b\") for b in books))</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"The map(container) do item; … ;end construct works and is performant.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<ul>$(map(books) do b @htl(\"<li>$b\") end)</ul>\")\n#=>\n<ul><li>Who Gets What &amp; Why<li>Switch<li>Governing The Commons</ul>\n=#","category":"page"},{"location":"#Attribute-Interpolation","page":"Usage","title":"Attribute Interpolation","text":"","category":"section"},{"location":"","page":"Usage","title":"Usage","text":"Interpolation within single and double quoted attribute values are supported. Regardless of context, all four characters are escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"qval = \"\\\"&'\"\n\n@print @htl(\"\"\"<tag double=\"$qval\" single='$qval' />\"\"\")\n#-> <tag double=\"&quot;&amp;&apos;\" single='&quot;&amp;&apos;' />","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Unquoted or bare attributes are also supported. These are serialized using the single quoted style so that spaces and other characters do not need to be escaped.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"arg = \"book='Strunk & White'\"\n\n@print @htl(\"<tag bare=$arg />\")\n#-> <tag bare='book=&apos;Strunk &amp; White&apos;' />","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Attributes may also be provided by any combination of dictionaries, named tuples, and pairs. Attribute names are normalized, where snake_case becomes kebab-case. We do not convert camelCase due to XML (MathML and SVG) attribute case sensitivity. Moreover, String attribute names are passed along as-is.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":" attributes = Dict(:data_style => :green, \"data_value\" => 42, )\n\n @print @htl(\"<div $attributes/>\")\n #-> <div data-style='green' data_value='42'/>\n\n @print @htl(\"<div $(:data_style=>:green) $(:dataValue=>42)/>\")\n #-> <div data-style='green' dataValue='42'/>\n\n @print @htl(\"<div $((:data_style=>:green, \"data_value\"=>42))/>\")\n #-> <div data-style='green' data_value='42'/>\n\n @print @htl(\"<div $((data_style=:green, dataValue=42))/>\")\n #-> <div data-style='green' dataValue='42'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"As you can see from this example, symbols and numbers (but not boolean values) are automatically printed within attributes. This interpolation works within quoted values as well.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"\"\"<tag numeric=\"$(0)\" symbol='$(:sym)'/>\"\"\")\n#-> <tag numeric=\"0\" symbol='sym'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Within bare attributes, boolean values provide special support for boolean HTML properties, such as \"disabled\". When a bare value false then the attribute is removed. When the value is true then the attribute is kept, with value being an empty string ('').","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<button checked=$(true) disabled=$(false)>\")\n#-> <button checked=''>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"Since boolean values are given special treatment, they become an error within quoted attribute values. At this time, this behavior is universal and does not depend upon the exact attribute used.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<button disabled='$(false)'>\")\n#-> ERROR: \"Boolean used within a quoted attribute.\"⋮","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"In HTML, many attributes specify values with space-delimited tokens, such as the Cascading Style Sheet (CSS) \"class\" attribute. To support these attributes, arrays and tuples produce space delimited output.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"@print @htl(\"<div class=$([:one, :two])/>\")\n#-> <div class='one two'/>\n\n@print @htl(\"<div class=$((:one, :two))/>\")\n#-> <div class='one two'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"To support nested key/value structures, such as the CSS \"style\" attribute, we have specialized expansion of dictionary like objects. For each pair, keys are separated from their value with a colon :, moreover, pairs are delimited by the semi-colon (;). Like attributes, snake_case is converted to kebab-case.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"header_styles = Dict(:font_size => \"25px\", \"padding-left\" => \"2em\")\n\n@print @htl(\"<div style=$header_styles/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@print @htl(\"<div style=$((:font_size=>\"25px\",\"padding-left\"=>\"2em\"))/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@print @htl(\"<div style=$((font_size=\"25px\", padding_left=\"2em\"))/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"These expansions work within quoted attributes.","category":"page"},{"location":"","page":"Usage","title":"Usage","text":"extra = Dict(:padding_left => \"2em\")\n\n@print @htl(\"<div style='font-size: 25px; $extra'/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>\n\n@print @htl(\"<div style='font-size: 25px; $(:padding_left => \"2em\")'/>\")\n#-> <div style='font-size: 25px; padding-left: 2em;'/>","category":"page"},{"location":"notation/#The-htl-notation-(non-standard-string-literal-macro)","page":"Notation","title":"The htl notation (non-standard string literal macro)","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"This package additionally provides the @htl_str notation which has the advantage of being more succinct than @htl macro.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"using HypertextLiteral: @htl_str\n\nmacro print(expr) :(display(\"text/html\", $expr)); end","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"name = \"World\"\n\nhtl\"<span>Hello $name</span>\"\n#-> htl\"<span>Hello $name</span>\"","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Strings prefixed by htl are processed by @htl_str.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"name = \"World\"\n\n@print htl\"<span>Hello $name</span>\"\n#-> <span>Hello World</span>\n\n@print @htl_str(\"<span>Hello \\$name</span>\")\n#-> <span>Hello World</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Other than a handful of exceptions, htl\"<tag/>\" and @htl(\"<tag/>\") are otherwise identical in behavior.","category":"page"},{"location":"notation/#Notable-Differences","page":"Notation","title":"Notable Differences","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"Unlike @htl, htl uses @raw_str escaping rules. In particular, so long as a double-quote character does not come before a slash, the slash itself need not be escaped.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"<span>\\some\\path</span>\"\n#-> <span>\\some\\path</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"To represent the dollar-sign, use use HTML character entity #&36;.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"amount = 42\n\n@print htl\"<span>They paid &#36;$amount</span>\"\n#-> <span>They paid &#36;42</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Unlike macros, this syntax does not nest.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"Hello $(htl\"World\")\"\n#-> ERROR: syntax: cannot juxtapose string literal","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Triple double-quoted syntax can be used as a work around.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"\"\"Hello $(htl\"World\")\"\"\"\n#-> Hello World","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"However, this trick works only one level deep. Hence, there are some significant downsides to using this format, which are explored in detail at Julia #38948.","category":"page"},{"location":"notation/#Marginal-Benefits","page":"Notation","title":"Marginal Benefits","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"Since the implementers of the notation have some control over the parsing, there are some benefits. First, we can reliably detect string literals (Julia #38501) before v1.6. This is fixed in Julia 1.6+","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"\"\"<span>$(\"A&B\")</span>\"\"\"\n#-> <span>A&amp;B</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Second, there is one less round of parenthesis needed for tuples, named tuples and generators (Julia #38734). This is especially useful when building attributes.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"name = \"Hello\"\n\n@print htl\"<tag $(user=name,)/>\"\n#-> <tag user='Hello'/>\n\n@print htl\"<span>$(n for n in 1:3)</span>\"\n#-> <span>123</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Beyond these differences, this could just be a matter of preference; or which form of syntax highlighting works best.","category":"page"},{"location":"notation/#Nesting-via-Paired-Unicode-Delimiter","page":"Notation","title":"Nesting via Paired Unicode Delimiter","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"We include an experimental prototype for use of paired delimiters to permit nesting of htl notations as described in Julia #38948.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"Hello $(htl⟪World⟫)\"\n#-> Hello World","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Either single or triple double quotes are still needed for the outermost query. As long as content uses paired delimiters, there is no problem including them verbatim.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"Hello ⟪World⟫\"\n#-> Hello ⟪World⟫\n\n@print htl\"Hello ⟪World⟫ $(htl⟪!⟫)\"\n#-> Hello ⟪World⟫ !","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"The dollar sign is still used to mark interpolation, if it is omitted, and we discover an htl⟪...⟫ pair, then we report it as an error.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"htl\"Hello htl⟪World⟫\"\n#=>\nERROR: LoadError: \"`htl⟪⟫` notation discovered outside interpolation\"⋮\n=#","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"To use the ⟪ in an unpaired way, it could be included in HTML content using a character entity.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"Hello ⟪\"\n#-> ERROR: LoadError: \"unmatched ⟪ delimiter\"⋮\n\n@print htl\"Hello ⟫\"\n#-> ERROR: LoadError: \"unmatched ⟫ delimiter\"⋮\n\n@print htl\"<span>nested literals start with &#10218;</span>\"\n#-> <span>nested literals start with &#10218;</span>","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"If this feature gains support we might keep this notation.","category":"page"},{"location":"notation/#Quirks-and-Notes","page":"Notation","title":"Quirks & Notes","text":"","category":"section"},{"location":"notation/","page":"Notation","title":"Notation","text":"Due to @raw_str escaping, string literal forms are a bit quirky. Use the triple double-quoted form if your content has a double quote. Avoid slashes preceding a double quote, instead use the &#47; HTML entity.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"@print htl\"\\\"\\t\\\\\"\n#-> \"\\t\\\n\n@print htl\"(\\\\\\\")\"\n#-> (\\\")","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"Even though we could permit interpretation of arrays notation, we stick with keeping this an error for consistency with the macro form.","category":"page"},{"location":"notation/","page":"Notation","title":"Notation","text":"htl\"$[1,2,3]\"\n#=>\nERROR: LoadError: DomainError with [1, 2, 3]:\ninterpolations must be symbols or parenthesized⋮\n=#","category":"page"}]
}
